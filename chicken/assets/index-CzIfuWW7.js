(function () { const t = document.createElement("link").relList; if (t && t.supports && t.supports("modulepreload")) return; for (const r of document.querySelectorAll('link[rel="modulepreload"]')) s(r); new MutationObserver(r => { for (const i of r) if (i.type === "childList") for (const o of i.addedNodes) o.tagName === "LINK" && o.rel === "modulepreload" && s(o) }).observe(document, { childList: !0, subtree: !0 }); function n(r) { const i = {}; return r.integrity && (i.integrity = r.integrity), r.referrerPolicy && (i.referrerPolicy = r.referrerPolicy), r.crossOrigin === "use-credentials" ? i.credentials = "include" : r.crossOrigin === "anonymous" ? i.credentials = "omit" : i.credentials = "same-origin", i } function s(r) { if (r.ep) return; r.ep = !0; const i = n(r); fetch(r.href, i) } })();/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function fs(e) { const t = Object.create(null); for (const n of e.split(",")) t[n] = 1; return n => n in t } const z = {}, lt = [], Le = () => { }, to = () => !1, un = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && (e.charCodeAt(2) > 122 || e.charCodeAt(2) < 97), us = e => e.startsWith("onUpdate:"), le = Object.assign, as = (e, t) => { const n = e.indexOf(t); n > -1 && e.splice(n, 1) }, no = Object.prototype.hasOwnProperty, $ = (e, t) => no.call(e, t), I = Array.isArray, ct = e => an(e) === "[object Map]", Rr = e => an(e) === "[object Set]", j = e => typeof e == "function", Y = e => typeof e == "string", Ve = e => typeof e == "symbol", G = e => e !== null && typeof e == "object", Or = e => (G(e) || j(e)) && j(e.then) && j(e.catch), Cr = Object.prototype.toString, an = e => Cr.call(e), so = e => an(e).slice(8, -1), Ar = e => an(e) === "[object Object]", ds = e => Y(e) && e !== "NaN" && e[0] !== "-" && "" + parseInt(e, 10) === e, Et = fs(",key,ref,ref_for,ref_key,onVnodeBeforeMount,onVnodeMounted,onVnodeBeforeUpdate,onVnodeUpdated,onVnodeBeforeUnmount,onVnodeUnmounted"), dn = e => { const t = Object.create(null); return n => t[n] || (t[n] = e(n)) }, ro = /-(\w)/g, ye = dn(e => e.replace(ro, (t, n) => n ? n.toUpperCase() : "")), io = /\B([A-Z])/g, rt = dn(e => e.replace(io, "-$1").toLowerCase()), hn = dn(e => e.charAt(0).toUpperCase() + e.slice(1)), Fn = dn(e => e ? `on${hn(e)}` : ""), et = (e, t) => !Object.is(e, t), Nn = (e, ...t) => { for (let n = 0; n < e.length; n++)e[n](...t) }, Pr = (e, t, n, s = !1) => { Object.defineProperty(e, t, { configurable: !0, enumerable: !1, writable: s, value: n }) }, oo = e => { const t = parseFloat(e); return isNaN(t) ? e : t }; let Hs; const pn = () => Hs || (Hs = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : typeof global < "u" ? global : {}); function hs(e) { if (I(e)) { const t = {}; for (let n = 0; n < e.length; n++) { const s = e[n], r = Y(s) ? uo(s) : hs(s); if (r) for (const i in r) t[i] = r[i] } return t } else if (Y(e) || G(e)) return e } const lo = /;(?![^(]*\))/g, co = /:([^]+)/, fo = /\/\*[^]*?\*\//g; function uo(e) { const t = {}; return e.replace(fo, "").split(lo).forEach(n => { if (n) { const s = n.split(co); s.length > 1 && (t[s[0].trim()] = s[1].trim()) } }), t } function ps(e) { let t = ""; if (Y(e)) t = e; else if (I(e)) for (let n = 0; n < e.length; n++) { const s = ps(e[n]); s && (t += s + " ") } else if (G(e)) for (const n in e) e[n] && (t += n + " "); return t.trim() } const ao = "itemscope,allowfullscreen,formnovalidate,ismap,nomodule,novalidate,readonly", ho = fs(ao); function Fr(e) { return !!e || e === "" } const Nr = e => !!(e && e.__v_isRef === !0), vr = e => Y(e) ? e : e == null ? "" : I(e) || G(e) && (e.toString === Cr || !j(e.toString)) ? Nr(e) ? vr(e.value) : JSON.stringify(e, Lr, 2) : String(e), Lr = (e, t) => Nr(t) ? Lr(e, t.value) : ct(t) ? { [`Map(${t.size})`]: [...t.entries()].reduce((n, [s, r], i) => (n[vn(s, i) + " =>"] = r, n), {}) } : Rr(t) ? { [`Set(${t.size})`]: [...t.values()].map(n => vn(n)) } : Ve(t) ? vn(t) : G(t) && !I(t) && !Ar(t) ? String(t) : t, vn = (e, t = "") => { var n; return Ve(e) ? `Symbol(${(n = e.description) != null ? n : t})` : e };/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let pe; class po { constructor(t = !1) { this.detached = t, this._active = !0, this.effects = [], this.cleanups = [], this._isPaused = !1, this.parent = pe, !t && pe && (this.index = (pe.scopes || (pe.scopes = [])).push(this) - 1) } get active() { return this._active } pause() { if (this._active) { this._isPaused = !0; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].pause(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].pause() } } resume() { if (this._active && this._isPaused) { this._isPaused = !1; let t, n; if (this.scopes) for (t = 0, n = this.scopes.length; t < n; t++)this.scopes[t].resume(); for (t = 0, n = this.effects.length; t < n; t++)this.effects[t].resume() } } run(t) { if (this._active) { const n = pe; try { return pe = this, t() } finally { pe = n } } } on() { pe = this } off() { pe = this.parent } stop(t) { if (this._active) { this._active = !1; let n, s; for (n = 0, s = this.effects.length; n < s; n++)this.effects[n].stop(); for (this.effects.length = 0, n = 0, s = this.cleanups.length; n < s; n++)this.cleanups[n](); if (this.cleanups.length = 0, this.scopes) { for (n = 0, s = this.scopes.length; n < s; n++)this.scopes[n].stop(!0); this.scopes.length = 0 } if (!this.detached && this.parent && !t) { const r = this.parent.scopes.pop(); r && r !== this && (this.parent.scopes[this.index] = r, r.index = this.index) } this.parent = void 0 } } } function mo() { return pe } let W; const Ln = new WeakSet; class Dr { constructor(t) { this.fn = t, this.deps = void 0, this.depsTail = void 0, this.flags = 5, this.next = void 0, this.cleanup = void 0, this.scheduler = void 0, pe && pe.active && pe.effects.push(this) } pause() { this.flags |= 64 } resume() { this.flags & 64 && (this.flags &= -65, Ln.has(this) && (Ln.delete(this), this.trigger())) } notify() { this.flags & 2 && !(this.flags & 32) || this.flags & 8 || Ir(this) } run() { if (!(this.flags & 1)) return this.fn(); this.flags |= 2, js(this), Hr(this); const t = W, n = we; W = this, we = !0; try { return this.fn() } finally { jr(this), W = t, we = n, this.flags &= -3 } } stop() { if (this.flags & 1) { for (let t = this.deps; t; t = t.nextDep)bs(t); this.deps = this.depsTail = void 0, js(this), this.onStop && this.onStop(), this.flags &= -2 } } trigger() { this.flags & 64 ? Ln.add(this) : this.scheduler ? this.scheduler() : this.runIfDirty() } runIfDirty() { Wn(this) && this.run() } get dirty() { return Wn(this) } } let Mr = 0, Tt, Rt; function Ir(e, t = !1) { if (e.flags |= 8, t) { e.next = Rt, Rt = e; return } e.next = Tt, Tt = e } function ms() { Mr++ } function gs() { if (--Mr > 0) return; if (Rt) { let t = Rt; for (Rt = void 0; t;) { const n = t.next; t.next = void 0, t.flags &= -9, t = n } } let e; for (; Tt;) { let t = Tt; for (Tt = void 0; t;) { const n = t.next; if (t.next = void 0, t.flags &= -9, t.flags & 1) try { t.trigger() } catch (s) { e || (e = s) } t = n } } if (e) throw e } function Hr(e) { for (let t = e.deps; t; t = t.nextDep)t.version = -1, t.prevActiveLink = t.dep.activeLink, t.dep.activeLink = t } function jr(e) { let t, n = e.depsTail, s = n; for (; s;) { const r = s.prevDep; s.version === -1 ? (s === n && (n = r), bs(s), go(s)) : t = s, s.dep.activeLink = s.prevActiveLink, s.prevActiveLink = void 0, s = r } e.deps = t, e.depsTail = n } function Wn(e) { for (let t = e.deps; t; t = t.nextDep)if (t.dep.version !== t.version || t.dep.computed && (Ur(t.dep.computed) || t.dep.version !== t.version)) return !0; return !!e._dirty } function Ur(e) { if (e.flags & 4 && !(e.flags & 16) || (e.flags &= -17, e.globalVersion === Ft)) return; e.globalVersion = Ft; const t = e.dep; if (e.flags |= 2, t.version > 0 && !e.isSSR && e.deps && !Wn(e)) { e.flags &= -3; return } const n = W, s = we; W = e, we = !0; try { Hr(e); const r = e.fn(e._value); (t.version === 0 || et(r, e._value)) && (e._value = r, t.version++) } catch (r) { throw t.version++, r } finally { W = n, we = s, jr(e), e.flags &= -3 } } function bs(e, t = !1) { const { dep: n, prevSub: s, nextSub: r } = e; if (s && (s.nextSub = r, e.prevSub = void 0), r && (r.prevSub = s, e.nextSub = void 0), n.subs === e && (n.subs = s, !s && n.computed)) { n.computed.flags &= -5; for (let i = n.computed.deps; i; i = i.nextDep)bs(i, !0) } !t && !--n.sc && n.map && n.map.delete(n.key) } function go(e) { const { prevDep: t, nextDep: n } = e; t && (t.nextDep = n, e.prevDep = void 0), n && (n.prevDep = t, e.nextDep = void 0) } let we = !0; const Br = []; function ke() { Br.push(we), we = !1 } function Ke() { const e = Br.pop(); we = e === void 0 ? !0 : e } function js(e) { const { cleanup: t } = e; if (e.cleanup = void 0, t) { const n = W; W = void 0; try { t() } finally { W = n } } } let Ft = 0; class bo { constructor(t, n) { this.sub = t, this.dep = n, this.version = n.version, this.nextDep = this.prevDep = this.nextSub = this.prevSub = this.prevActiveLink = void 0 } } class $r { constructor(t) { this.computed = t, this.version = 0, this.activeLink = void 0, this.subs = void 0, this.map = void 0, this.key = void 0, this.sc = 0 } track(t) { if (!W || !we || W === this.computed) return; let n = this.activeLink; if (n === void 0 || n.sub !== W) n = this.activeLink = new bo(W, this), W.deps ? (n.prevDep = W.depsTail, W.depsTail.nextDep = n, W.depsTail = n) : W.deps = W.depsTail = n, qr(n); else if (n.version === -1 && (n.version = this.version, n.nextDep)) { const s = n.nextDep; s.prevDep = n.prevDep, n.prevDep && (n.prevDep.nextDep = s), n.prevDep = W.depsTail, n.nextDep = void 0, W.depsTail.nextDep = n, W.depsTail = n, W.deps === n && (W.deps = s) } return n } trigger(t) { this.version++, Ft++, this.notify(t) } notify(t) { ms(); try { for (let n = this.subs; n; n = n.prevSub)n.sub.notify() && n.sub.dep.notify() } finally { gs() } } } function qr(e) { if (e.dep.sc++, e.sub.flags & 4) { const t = e.dep.computed; if (t && !e.dep.subs) { t.flags |= 20; for (let s = t.deps; s; s = s.nextDep)qr(s) } const n = e.dep.subs; n !== e && (e.prevSub = n, n && (n.nextSub = e)), e.dep.subs = e } } const zn = new WeakMap, tt = Symbol(""), Jn = Symbol(""), Nt = Symbol(""); function ee(e, t, n) { if (we && W) { let s = zn.get(e); s || zn.set(e, s = new Map); let r = s.get(n); r || (s.set(n, r = new $r), r.map = s, r.key = n), r.track() } } function je(e, t, n, s, r, i) { const o = zn.get(e); if (!o) { Ft++; return } const l = c => { c && c.trigger() }; if (ms(), t === "clear") o.forEach(l); else { const c = I(e), d = c && ds(n); if (c && n === "length") { const u = Number(s); o.forEach((h, w) => { (w === "length" || w === Nt || !Ve(w) && w >= u) && l(h) }) } else switch ((n !== void 0 || o.has(void 0)) && l(o.get(n)), d && l(o.get(Nt)), t) { case "add": c ? d && l(o.get("length")) : (l(o.get(tt)), ct(e) && l(o.get(Jn))); break; case "delete": c || (l(o.get(tt)), ct(e) && l(o.get(Jn))); break; case "set": ct(e) && l(o.get(tt)); break } } gs() } function it(e) { const t = V(e); return t === e ? t : (ee(t, "iterate", Nt), De(e) ? t : t.map(me)) } function ys(e) { return ee(e = V(e), "iterate", Nt), e } const yo = { __proto__: null, [Symbol.iterator]() { return Dn(this, Symbol.iterator, me) }, concat(...e) { return it(this).concat(...e.map(t => I(t) ? it(t) : t)) }, entries() { return Dn(this, "entries", e => (e[1] = me(e[1]), e)) }, every(e, t) { return Ie(this, "every", e, t, void 0, arguments) }, filter(e, t) { return Ie(this, "filter", e, t, n => n.map(me), arguments) }, find(e, t) { return Ie(this, "find", e, t, me, arguments) }, findIndex(e, t) { return Ie(this, "findIndex", e, t, void 0, arguments) }, findLast(e, t) { return Ie(this, "findLast", e, t, me, arguments) }, findLastIndex(e, t) { return Ie(this, "findLastIndex", e, t, void 0, arguments) }, forEach(e, t) { return Ie(this, "forEach", e, t, void 0, arguments) }, includes(...e) { return Mn(this, "includes", e) }, indexOf(...e) { return Mn(this, "indexOf", e) }, join(e) { return it(this).join(e) }, lastIndexOf(...e) { return Mn(this, "lastIndexOf", e) }, map(e, t) { return Ie(this, "map", e, t, void 0, arguments) }, pop() { return _t(this, "pop") }, push(...e) { return _t(this, "push", e) }, reduce(e, ...t) { return Us(this, "reduce", e, t) }, reduceRight(e, ...t) { return Us(this, "reduceRight", e, t) }, shift() { return _t(this, "shift") }, some(e, t) { return Ie(this, "some", e, t, void 0, arguments) }, splice(...e) { return _t(this, "splice", e) }, toReversed() { return it(this).toReversed() }, toSorted(e) { return it(this).toSorted(e) }, toSpliced(...e) { return it(this).toSpliced(...e) }, unshift(...e) { return _t(this, "unshift", e) }, values() { return Dn(this, "values", me) } }; function Dn(e, t, n) { const s = ys(e), r = s[t](); return s !== e && !De(e) && (r._next = r.next, r.next = () => { const i = r._next(); return i.value && (i.value = n(i.value)), i }), r } const _o = Array.prototype; function Ie(e, t, n, s, r, i) { const o = ys(e), l = o !== e && !De(e), c = o[t]; if (c !== _o[t]) { const h = c.apply(e, i); return l ? me(h) : h } let d = n; o !== e && (l ? d = function (h, w) { return n.call(this, me(h), w, e) } : n.length > 2 && (d = function (h, w) { return n.call(this, h, w, e) })); const u = c.call(o, d, s); return l && r ? r(u) : u } function Us(e, t, n, s) { const r = ys(e); let i = n; return r !== e && (De(e) ? n.length > 3 && (i = function (o, l, c) { return n.call(this, o, l, c, e) }) : i = function (o, l, c) { return n.call(this, o, me(l), c, e) }), r[t](i, ...s) } function Mn(e, t, n) { const s = V(e); ee(s, "iterate", Nt); const r = s[t](...n); return (r === -1 || r === !1) && Ss(n[0]) ? (n[0] = V(n[0]), s[t](...n)) : r } function _t(e, t, n = []) { ke(), ms(); const s = V(e)[t].apply(e, n); return gs(), Ke(), s } const wo = fs("__proto__,__v_isRef,__isVue"), Vr = new Set(Object.getOwnPropertyNames(Symbol).filter(e => e !== "arguments" && e !== "caller").map(e => Symbol[e]).filter(Ve)); function xo(e) { Ve(e) || (e = String(e)); const t = V(this); return ee(t, "has", e), t.hasOwnProperty(e) } class kr { constructor(t = !1, n = !1) { this._isReadonly = t, this._isShallow = n } get(t, n, s) { if (n === "__v_skip") return t.__v_skip; const r = this._isReadonly, i = this._isShallow; if (n === "__v_isReactive") return !r; if (n === "__v_isReadonly") return r; if (n === "__v_isShallow") return i; if (n === "__v_raw") return s === (r ? i ? No : Jr : i ? zr : Wr).get(t) || Object.getPrototypeOf(t) === Object.getPrototypeOf(s) ? t : void 0; const o = I(t); if (!r) { let c; if (o && (c = yo[n])) return c; if (n === "hasOwnProperty") return xo } const l = Reflect.get(t, n, oe(t) ? t : s); return (Ve(n) ? Vr.has(n) : wo(n)) || (r || ee(t, "get", n), i) ? l : oe(l) ? o && ds(n) ? l : l.value : G(l) ? r ? Gr(l) : ws(l) : l } } class Kr extends kr { constructor(t = !1) { super(!1, t) } set(t, n, s, r) { let i = t[n]; if (!this._isShallow) { const c = at(i); if (!De(s) && !at(s) && (i = V(i), s = V(s)), !I(t) && oe(i) && !oe(s)) return c ? !1 : (i.value = s, !0) } const o = I(t) && ds(n) ? Number(n) < t.length : $(t, n), l = Reflect.set(t, n, s, oe(t) ? t : r); return t === V(r) && (o ? et(s, i) && je(t, "set", n, s) : je(t, "add", n, s)), l } deleteProperty(t, n) { const s = $(t, n); t[n]; const r = Reflect.deleteProperty(t, n); return r && s && je(t, "delete", n, void 0), r } has(t, n) { const s = Reflect.has(t, n); return (!Ve(n) || !Vr.has(n)) && ee(t, "has", n), s } ownKeys(t) { return ee(t, "iterate", I(t) ? "length" : tt), Reflect.ownKeys(t) } } class So extends kr { constructor(t = !1) { super(!0, t) } set(t, n) { return !0 } deleteProperty(t, n) { return !0 } } const Eo = new Kr, To = new So, Ro = new Kr(!0); const Gn = e => e, Kt = e => Reflect.getPrototypeOf(e); function Oo(e, t, n) { return function (...s) { const r = this.__v_raw, i = V(r), o = ct(i), l = e === "entries" || e === Symbol.iterator && o, c = e === "keys" && o, d = r[e](...s), u = n ? Gn : t ? Xn : me; return !t && ee(i, "iterate", c ? Jn : tt), { next() { const { value: h, done: w } = d.next(); return w ? { value: h, done: w } : { value: l ? [u(h[0]), u(h[1])] : u(h), done: w } }, [Symbol.iterator]() { return this } } } } function Wt(e) { return function (...t) { return e === "delete" ? !1 : e === "clear" ? void 0 : this } } function Co(e, t) { const n = { get(r) { const i = this.__v_raw, o = V(i), l = V(r); e || (et(r, l) && ee(o, "get", r), ee(o, "get", l)); const { has: c } = Kt(o), d = t ? Gn : e ? Xn : me; if (c.call(o, r)) return d(i.get(r)); if (c.call(o, l)) return d(i.get(l)); i !== o && i.get(r) }, get size() { const r = this.__v_raw; return !e && ee(V(r), "iterate", tt), Reflect.get(r, "size", r) }, has(r) { const i = this.__v_raw, o = V(i), l = V(r); return e || (et(r, l) && ee(o, "has", r), ee(o, "has", l)), r === l ? i.has(r) : i.has(r) || i.has(l) }, forEach(r, i) { const o = this, l = o.__v_raw, c = V(l), d = t ? Gn : e ? Xn : me; return !e && ee(c, "iterate", tt), l.forEach((u, h) => r.call(i, d(u), d(h), o)) } }; return le(n, e ? { add: Wt("add"), set: Wt("set"), delete: Wt("delete"), clear: Wt("clear") } : { add(r) { !t && !De(r) && !at(r) && (r = V(r)); const i = V(this); return Kt(i).has.call(i, r) || (i.add(r), je(i, "add", r, r)), this }, set(r, i) { !t && !De(i) && !at(i) && (i = V(i)); const o = V(this), { has: l, get: c } = Kt(o); let d = l.call(o, r); d || (r = V(r), d = l.call(o, r)); const u = c.call(o, r); return o.set(r, i), d ? et(i, u) && je(o, "set", r, i) : je(o, "add", r, i), this }, delete(r) { const i = V(this), { has: o, get: l } = Kt(i); let c = o.call(i, r); c || (r = V(r), c = o.call(i, r)), l && l.call(i, r); const d = i.delete(r); return c && je(i, "delete", r, void 0), d }, clear() { const r = V(this), i = r.size !== 0, o = r.clear(); return i && je(r, "clear", void 0, void 0), o } }), ["keys", "values", "entries", Symbol.iterator].forEach(r => { n[r] = Oo(r, e, t) }), n } function _s(e, t) { const n = Co(e, t); return (s, r, i) => r === "__v_isReactive" ? !e : r === "__v_isReadonly" ? e : r === "__v_raw" ? s : Reflect.get($(n, r) && r in s ? n : s, r, i) } const Ao = { get: _s(!1, !1) }, Po = { get: _s(!1, !0) }, Fo = { get: _s(!0, !1) }; const Wr = new WeakMap, zr = new WeakMap, Jr = new WeakMap, No = new WeakMap; function vo(e) { switch (e) { case "Object": case "Array": return 1; case "Map": case "Set": case "WeakMap": case "WeakSet": return 2; default: return 0 } } function Lo(e) { return e.__v_skip || !Object.isExtensible(e) ? 0 : vo(so(e)) } function ws(e) { return at(e) ? e : xs(e, !1, Eo, Ao, Wr) } function Do(e) { return xs(e, !1, Ro, Po, zr) } function Gr(e) { return xs(e, !0, To, Fo, Jr) } function xs(e, t, n, s, r) { if (!G(e) || e.__v_raw && !(t && e.__v_isReactive)) return e; const i = r.get(e); if (i) return i; const o = Lo(e); if (o === 0) return e; const l = new Proxy(e, o === 2 ? s : n); return r.set(e, l), l } function Ot(e) { return at(e) ? Ot(e.__v_raw) : !!(e && e.__v_isReactive) } function at(e) { return !!(e && e.__v_isReadonly) } function De(e) { return !!(e && e.__v_isShallow) } function Ss(e) { return e ? !!e.__v_raw : !1 } function V(e) { const t = e && e.__v_raw; return t ? V(t) : e } function Mo(e) { return !$(e, "__v_skip") && Object.isExtensible(e) && Pr(e, "__v_skip", !0), e } const me = e => G(e) ? ws(e) : e, Xn = e => G(e) ? Gr(e) : e; function oe(e) { return e ? e.__v_isRef === !0 : !1 } function Io(e) { return oe(e) ? e.value : e } const Ho = { get: (e, t, n) => t === "__v_raw" ? e : Io(Reflect.get(e, t, n)), set: (e, t, n, s) => { const r = e[t]; return oe(r) && !oe(n) ? (r.value = n, !0) : Reflect.set(e, t, n, s) } }; function Xr(e) { return Ot(e) ? e : new Proxy(e, Ho) } class jo { constructor(t, n, s) { this.fn = t, this.setter = n, this._value = void 0, this.dep = new $r(this), this.__v_isRef = !0, this.deps = void 0, this.depsTail = void 0, this.flags = 16, this.globalVersion = Ft - 1, this.next = void 0, this.effect = this, this.__v_isReadonly = !n, this.isSSR = s } notify() { if (this.flags |= 16, !(this.flags & 8) && W !== this) return Ir(this, !0), !0 } get value() { const t = this.dep.track(); return Ur(this), t && (t.version = this.dep.version), this._value } set value(t) { this.setter && this.setter(t) } } function Uo(e, t, n = !1) { let s, r; return j(e) ? s = e : (s = e.get, r = e.set), new jo(s, r, n) } const zt = {}, tn = new WeakMap; let Ze; function Bo(e, t = !1, n = Ze) { if (n) { let s = tn.get(n); s || tn.set(n, s = []), s.push(e) } } function $o(e, t, n = z) { const { immediate: s, deep: r, once: i, scheduler: o, augmentJob: l, call: c } = n, d = P => r ? P : De(P) || r === !1 || r === 0 ? qe(P, 1) : qe(P); let u, h, w, T, x = !1, R = !1; if (oe(e) ? (h = () => e.value, x = De(e)) : Ot(e) ? (h = () => d(e), x = !0) : I(e) ? (R = !0, x = e.some(P => Ot(P) || De(P)), h = () => e.map(P => { if (oe(P)) return P.value; if (Ot(P)) return d(P); if (j(P)) return c ? c(P, 2) : P() })) : j(e) ? t ? h = c ? () => c(e, 2) : e : h = () => { if (w) { ke(); try { w() } finally { Ke() } } const P = Ze; Ze = u; try { return c ? c(e, 3, [T]) : e(T) } finally { Ze = P } } : h = Le, t && r) { const P = h, U = r === !0 ? 1 / 0 : r; h = () => qe(P(), U) } const C = mo(), N = () => { u.stop(), C && C.active && as(C.effects, u) }; if (i && t) { const P = t; t = (...U) => { P(...U), N() } } let D = R ? new Array(e.length).fill(zt) : zt; const H = P => { if (!(!(u.flags & 1) || !u.dirty && !P)) if (t) { const U = u.run(); if (r || x || (R ? U.some((Q, Z) => et(Q, D[Z])) : et(U, D))) { w && w(); const Q = Ze; Ze = u; try { const Z = [U, D === zt ? void 0 : R && D[0] === zt ? [] : D, T]; c ? c(t, 3, Z) : t(...Z), D = U } finally { Ze = Q } } } else u.run() }; return l && l(H), u = new Dr(h), u.scheduler = o ? () => o(H, !1) : H, T = P => Bo(P, !1, u), w = u.onStop = () => { const P = tn.get(u); if (P) { if (c) c(P, 4); else for (const U of P) U(); tn.delete(u) } }, t ? s ? H(!0) : D = u.run() : o ? o(H.bind(null, !0), !0) : u.run(), N.pause = u.pause.bind(u), N.resume = u.resume.bind(u), N.stop = N, N } function qe(e, t = 1 / 0, n) { if (t <= 0 || !G(e) || e.__v_skip || (n = n || new Set, n.has(e))) return e; if (n.add(e), t--, oe(e)) qe(e.value, t, n); else if (I(e)) for (let s = 0; s < e.length; s++)qe(e[s], t, n); else if (Rr(e) || ct(e)) e.forEach(s => { qe(s, t, n) }); else if (Ar(e)) { for (const s in e) qe(e[s], t, n); for (const s of Object.getOwnPropertySymbols(e)) Object.prototype.propertyIsEnumerable.call(e, s) && qe(e[s], t, n) } return e }/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Ht(e, t, n, s) { try { return s ? e(...s) : e() } catch (r) { mn(r, t, n) } } function Me(e, t, n, s) { if (j(e)) { const r = Ht(e, t, n, s); return r && Or(r) && r.catch(i => { mn(i, t, n) }), r } if (I(e)) { const r = []; for (let i = 0; i < e.length; i++)r.push(Me(e[i], t, n, s)); return r } } function mn(e, t, n, s = !0) { const r = t ? t.vnode : null, { errorHandler: i, throwUnhandledErrorInProduction: o } = t && t.appContext.config || z; if (t) { let l = t.parent; const c = t.proxy, d = `https://vuejs.org/error-reference/#runtime-${n}`; for (; l;) { const u = l.ec; if (u) { for (let h = 0; h < u.length; h++)if (u[h](e, c, d) === !1) return } l = l.parent } if (i) { ke(), Ht(i, null, 10, [e, c, d]), Ke(); return } } qo(e, n, r, s, o) } function qo(e, t, n, s = !0, r = !1) { if (r) throw e; console.error(e) } const ie = []; let Pe = -1; const ft = []; let Be = null, ot = 0; const Yr = Promise.resolve(); let nn = null; function Vo(e) { const t = nn || Yr; return e ? t.then(this ? e.bind(this) : e) : t } function ko(e) { let t = Pe + 1, n = ie.length; for (; t < n;) { const s = t + n >>> 1, r = ie[s], i = vt(r); i < e || i === e && r.flags & 2 ? t = s + 1 : n = s } return t } function Es(e) { if (!(e.flags & 1)) { const t = vt(e), n = ie[ie.length - 1]; !n || !(e.flags & 2) && t >= vt(n) ? ie.push(e) : ie.splice(ko(t), 0, e), e.flags |= 1, Zr() } } function Zr() { nn || (nn = Yr.then(ei)) } function Ko(e) { I(e) ? ft.push(...e) : Be && e.id === -1 ? Be.splice(ot + 1, 0, e) : e.flags & 1 || (ft.push(e), e.flags |= 1), Zr() } function Bs(e, t, n = Pe + 1) { for (; n < ie.length; n++) { const s = ie[n]; if (s && s.flags & 2) { if (e && s.id !== e.uid) continue; ie.splice(n, 1), n--, s.flags & 4 && (s.flags &= -2), s(), s.flags & 4 || (s.flags &= -2) } } } function Qr(e) { if (ft.length) { const t = [...new Set(ft)].sort((n, s) => vt(n) - vt(s)); if (ft.length = 0, Be) { Be.push(...t); return } for (Be = t, ot = 0; ot < Be.length; ot++) { const n = Be[ot]; n.flags & 4 && (n.flags &= -2), n.flags & 8 || n(), n.flags &= -2 } Be = null, ot = 0 } } const vt = e => e.id == null ? e.flags & 2 ? -1 : 1 / 0 : e.id; function ei(e) { try { for (Pe = 0; Pe < ie.length; Pe++) { const t = ie[Pe]; t && !(t.flags & 8) && (t.flags & 4 && (t.flags &= -2), Ht(t, t.i, t.i ? 15 : 14), t.flags & 4 || (t.flags &= -2)) } } finally { for (; Pe < ie.length; Pe++) { const t = ie[Pe]; t && (t.flags &= -2) } Pe = -1, ie.length = 0, Qr(), nn = null, (ie.length || ft.length) && ei() } } let _e = null, ti = null; function sn(e) { const t = _e; return _e = e, ti = e && e.type.__scopeId || null, t } function Wo(e, t = _e, n) { if (!t || e._n) return e; const s = (...r) => { s._d && Xs(-1); const i = sn(t); let o; try { o = e(...r) } finally { sn(i), s._d && Xs(1) } return o }; return s._n = !0, s._c = !0, s._d = !0, s } function Xe(e, t, n, s) { const r = e.dirs, i = t && t.dirs; for (let o = 0; o < r.length; o++) { const l = r[o]; i && (l.oldValue = i[o].value); let c = l.dir[s]; c && (ke(), Me(c, n, 8, [e.el, l, e, t]), Ke()) } } const zo = Symbol("_vte"), Jo = e => e.__isTeleport; function Ts(e, t) { e.shapeFlag & 6 && e.component ? (e.transition = t, Ts(e.component.subTree, t)) : e.shapeFlag & 128 ? (e.ssContent.transition = t.clone(e.ssContent), e.ssFallback.transition = t.clone(e.ssFallback)) : e.transition = t } function ni(e) { e.ids = [e.ids[0] + e.ids[2]++ + "-", 0, 0] } function rn(e, t, n, s, r = !1) { if (I(e)) { e.forEach((x, R) => rn(x, t && (I(t) ? t[R] : t), n, s, r)); return } if (Ct(s) && !r) { s.shapeFlag & 512 && s.type.__asyncResolved && s.component.subTree.component && rn(e, t, n, s.component.subTree); return } const i = s.shapeFlag & 4 ? Cs(s.component) : s.el, o = r ? null : i, { i: l, r: c } = e, d = t && t.r, u = l.refs === z ? l.refs = {} : l.refs, h = l.setupState, w = V(h), T = h === z ? () => !1 : x => $(w, x); if (d != null && d !== c && (Y(d) ? (u[d] = null, T(d) && (h[d] = null)) : oe(d) && (d.value = null)), j(c)) Ht(c, l, 12, [o, u]); else { const x = Y(c), R = oe(c); if (x || R) { const C = () => { if (e.f) { const N = x ? T(c) ? h[c] : u[c] : c.value; r ? I(N) && as(N, i) : I(N) ? N.includes(i) || N.push(i) : x ? (u[c] = [i], T(c) && (h[c] = u[c])) : (c.value = [i], e.k && (u[e.k] = c.value)) } else x ? (u[c] = o, T(c) && (h[c] = o)) : R && (c.value = o, e.k && (u[e.k] = o)) }; o ? (C.id = -1, he(C, n)) : C() } } } pn().requestIdleCallback; pn().cancelIdleCallback; const Ct = e => !!e.type.__asyncLoader, si = e => e.type.__isKeepAlive; function Go(e, t) { ri(e, "a", t) } function Xo(e, t) { ri(e, "da", t) } function ri(e, t, n = te) { const s = e.__wdc || (e.__wdc = () => { let r = n; for (; r;) { if (r.isDeactivated) return; r = r.parent } return e() }); if (gn(t, s, n), n) { let r = n.parent; for (; r && r.parent;)si(r.parent.vnode) && Yo(s, t, n, r), r = r.parent } } function Yo(e, t, n, s) { const r = gn(t, e, s, !0); ii(() => { as(s[t], r) }, n) } function gn(e, t, n = te, s = !1) { if (n) { const r = n[e] || (n[e] = []), i = t.__weh || (t.__weh = (...o) => { ke(); const l = jt(n), c = Me(t, n, e, o); return l(), Ke(), c }); return s ? r.unshift(i) : r.push(i), i } } const Ue = e => (t, n = te) => { (!Mt || e === "sp") && gn(e, (...s) => t(...s), n) }, Zo = Ue("bm"), Qo = Ue("m"), el = Ue("bu"), tl = Ue("u"), nl = Ue("bum"), ii = Ue("um"), sl = Ue("sp"), rl = Ue("rtg"), il = Ue("rtc"); function ol(e, t = te) { gn("ec", e, t) } const ll = "components"; function In(e, t) { return fl(ll, e, !0, t) || e } const cl = Symbol.for("v-ndc"); function fl(e, t, n = !0, s = !1) { const r = _e || te; if (r) { const i = r.type; { const l = Ql(i, !1); if (l && (l === t || l === ye(t) || l === hn(ye(t)))) return i } const o = $s(r[e] || i[e], t) || $s(r.appContext[e], t); return !o && s ? i : o } } function $s(e, t) { return e && (e[t] || e[ye(t)] || e[hn(ye(t))]) } const Yn = e => e ? Oi(e) ? Cs(e) : Yn(e.parent) : null, At = le(Object.create(null), { $: e => e, $el: e => e.vnode.el, $data: e => e.data, $props: e => e.props, $attrs: e => e.attrs, $slots: e => e.slots, $refs: e => e.refs, $parent: e => Yn(e.parent), $root: e => Yn(e.root), $host: e => e.ce, $emit: e => e.emit, $options: e => li(e), $forceUpdate: e => e.f || (e.f = () => { Es(e.update) }), $nextTick: e => e.n || (e.n = Vo.bind(e.proxy)), $watch: e => Nl.bind(e) }), Hn = (e, t) => e !== z && !e.__isScriptSetup && $(e, t), ul = { get({ _: e }, t) { if (t === "__v_skip") return !0; const { ctx: n, setupState: s, data: r, props: i, accessCache: o, type: l, appContext: c } = e; let d; if (t[0] !== "$") { const T = o[t]; if (T !== void 0) switch (T) { case 1: return s[t]; case 2: return r[t]; case 4: return n[t]; case 3: return i[t] } else { if (Hn(s, t)) return o[t] = 1, s[t]; if (r !== z && $(r, t)) return o[t] = 2, r[t]; if ((d = e.propsOptions[0]) && $(d, t)) return o[t] = 3, i[t]; if (n !== z && $(n, t)) return o[t] = 4, n[t]; Zn && (o[t] = 0) } } const u = At[t]; let h, w; if (u) return t === "$attrs" && ee(e.attrs, "get", ""), u(e); if ((h = l.__cssModules) && (h = h[t])) return h; if (n !== z && $(n, t)) return o[t] = 4, n[t]; if (w = c.config.globalProperties, $(w, t)) return w[t] }, set({ _: e }, t, n) { const { data: s, setupState: r, ctx: i } = e; return Hn(r, t) ? (r[t] = n, !0) : s !== z && $(s, t) ? (s[t] = n, !0) : $(e.props, t) || t[0] === "$" && t.slice(1) in e ? !1 : (i[t] = n, !0) }, has({ _: { data: e, setupState: t, accessCache: n, ctx: s, appContext: r, propsOptions: i } }, o) { let l; return !!n[o] || e !== z && $(e, o) || Hn(t, o) || (l = i[0]) && $(l, o) || $(s, o) || $(At, o) || $(r.config.globalProperties, o) }, defineProperty(e, t, n) { return n.get != null ? e._.accessCache[t] = 0 : $(n, "value") && this.set(e, t, n.value, null), Reflect.defineProperty(e, t, n) } }; function qs(e) { return I(e) ? e.reduce((t, n) => (t[n] = null, t), {}) : e } let Zn = !0; function al(e) { const t = li(e), n = e.proxy, s = e.ctx; Zn = !1, t.beforeCreate && Vs(t.beforeCreate, e, "bc"); const { data: r, computed: i, methods: o, watch: l, provide: c, inject: d, created: u, beforeMount: h, mounted: w, beforeUpdate: T, updated: x, activated: R, deactivated: C, beforeDestroy: N, beforeUnmount: D, destroyed: H, unmounted: P, render: U, renderTracked: Q, renderTriggered: Z, errorCaptured: ue, serverPrefetch: We, expose: ze, inheritAttrs: mt, components: $t, directives: qt, filters: An } = t; if (d && dl(d, s, null), o) for (const J in o) { const k = o[J]; j(k) && (s[J] = k.bind(n)) } if (r) { const J = r.call(n, n); G(J) && (e.data = ws(J)) } if (Zn = !0, i) for (const J in i) { const k = i[J], Je = j(k) ? k.bind(n, n) : j(k.get) ? k.get.bind(n, n) : Le, Vt = !j(k) && j(k.set) ? k.set.bind(n) : Le, Ge = tc({ get: Je, set: Vt }); Object.defineProperty(s, J, { enumerable: !0, configurable: !0, get: () => Ge.value, set: Ee => Ge.value = Ee }) } if (l) for (const J in l) oi(l[J], s, n, J); if (c) { const J = j(c) ? c.call(n) : c; Reflect.ownKeys(J).forEach(k => { yl(k, J[k]) }) } u && Vs(u, e, "c"); function se(J, k) { I(k) ? k.forEach(Je => J(Je.bind(n))) : k && J(k.bind(n)) } if (se(Zo, h), se(Qo, w), se(el, T), se(tl, x), se(Go, R), se(Xo, C), se(ol, ue), se(il, Q), se(rl, Z), se(nl, D), se(ii, P), se(sl, We), I(ze)) if (ze.length) { const J = e.exposed || (e.exposed = {}); ze.forEach(k => { Object.defineProperty(J, k, { get: () => n[k], set: Je => n[k] = Je }) }) } else e.exposed || (e.exposed = {}); U && e.render === Le && (e.render = U), mt != null && (e.inheritAttrs = mt), $t && (e.components = $t), qt && (e.directives = qt), We && ni(e) } function dl(e, t, n = Le) { I(e) && (e = Qn(e)); for (const s in e) { const r = e[s]; let i; G(r) ? "default" in r ? i = Jt(r.from || s, r.default, !0) : i = Jt(r.from || s) : i = Jt(r), oe(i) ? Object.defineProperty(t, s, { enumerable: !0, configurable: !0, get: () => i.value, set: o => i.value = o }) : t[s] = i } } function Vs(e, t, n) { Me(I(e) ? e.map(s => s.bind(t.proxy)) : e.bind(t.proxy), t, n) } function oi(e, t, n, s) { let r = s.includes(".") ? xi(n, s) : () => n[s]; if (Y(e)) { const i = t[e]; j(i) && Un(r, i) } else if (j(e)) Un(r, e.bind(n)); else if (G(e)) if (I(e)) e.forEach(i => oi(i, t, n, s)); else { const i = j(e.handler) ? e.handler.bind(n) : t[e.handler]; j(i) && Un(r, i, e) } } function li(e) { const t = e.type, { mixins: n, extends: s } = t, { mixins: r, optionsCache: i, config: { optionMergeStrategies: o } } = e.appContext, l = i.get(t); let c; return l ? c = l : !r.length && !n && !s ? c = t : (c = {}, r.length && r.forEach(d => on(c, d, o, !0)), on(c, t, o)), G(t) && i.set(t, c), c } function on(e, t, n, s = !1) { const { mixins: r, extends: i } = t; i && on(e, i, n, !0), r && r.forEach(o => on(e, o, n, !0)); for (const o in t) if (!(s && o === "expose")) { const l = hl[o] || n && n[o]; e[o] = l ? l(e[o], t[o]) : t[o] } return e } const hl = { data: ks, props: Ks, emits: Ks, methods: St, computed: St, beforeCreate: re, created: re, beforeMount: re, mounted: re, beforeUpdate: re, updated: re, beforeDestroy: re, beforeUnmount: re, destroyed: re, unmounted: re, activated: re, deactivated: re, errorCaptured: re, serverPrefetch: re, components: St, directives: St, watch: ml, provide: ks, inject: pl }; function ks(e, t) { return t ? e ? function () { return le(j(e) ? e.call(this, this) : e, j(t) ? t.call(this, this) : t) } : t : e } function pl(e, t) { return St(Qn(e), Qn(t)) } function Qn(e) { if (I(e)) { const t = {}; for (let n = 0; n < e.length; n++)t[e[n]] = e[n]; return t } return e } function re(e, t) { return e ? [...new Set([].concat(e, t))] : t } function St(e, t) { return e ? le(Object.create(null), e, t) : t } function Ks(e, t) { return e ? I(e) && I(t) ? [...new Set([...e, ...t])] : le(Object.create(null), qs(e), qs(t ?? {})) : t } function ml(e, t) { if (!e) return t; if (!t) return e; const n = le(Object.create(null), e); for (const s in t) n[s] = re(e[s], t[s]); return n } function ci() { return { app: null, config: { isNativeTag: to, performance: !1, globalProperties: {}, optionMergeStrategies: {}, errorHandler: void 0, warnHandler: void 0, compilerOptions: {} }, mixins: [], components: {}, directives: {}, provides: Object.create(null), optionsCache: new WeakMap, propsCache: new WeakMap, emitsCache: new WeakMap } } let gl = 0; function bl(e, t) { return function (s, r = null) { j(s) || (s = le({}, s)), r != null && !G(r) && (r = null); const i = ci(), o = new WeakSet, l = []; let c = !1; const d = i.app = { _uid: gl++, _component: s, _props: r, _container: null, _context: i, _instance: null, version: nc, get config() { return i.config }, set config(u) { }, use(u, ...h) { return o.has(u) || (u && j(u.install) ? (o.add(u), u.install(d, ...h)) : j(u) && (o.add(u), u(d, ...h))), d }, mixin(u) { return i.mixins.includes(u) || i.mixins.push(u), d }, component(u, h) { return h ? (i.components[u] = h, d) : i.components[u] }, directive(u, h) { return h ? (i.directives[u] = h, d) : i.directives[u] }, mount(u, h, w) { if (!c) { const T = d._ceVNode || xe(s, r); return T.appContext = i, w === !0 ? w = "svg" : w === !1 && (w = void 0), e(T, u, w), c = !0, d._container = u, u.__vue_app__ = d, Cs(T.component) } }, onUnmount(u) { l.push(u) }, unmount() { c && (Me(l, d._instance, 16), e(null, d._container), delete d._container.__vue_app__) }, provide(u, h) { return i.provides[u] = h, d }, runWithContext(u) { const h = ut; ut = d; try { return u() } finally { ut = h } } }; return d } } let ut = null; function yl(e, t) { if (te) { let n = te.provides; const s = te.parent && te.parent.provides; s === n && (n = te.provides = Object.create(s)), n[e] = t } } function Jt(e, t, n = !1) { const s = te || _e; if (s || ut) { const r = ut ? ut._context.provides : s ? s.parent == null ? s.vnode.appContext && s.vnode.appContext.provides : s.parent.provides : void 0; if (r && e in r) return r[e]; if (arguments.length > 1) return n && j(t) ? t.call(s && s.proxy) : t } } const fi = {}, ui = () => Object.create(fi), ai = e => Object.getPrototypeOf(e) === fi; function _l(e, t, n, s = !1) { const r = {}, i = ui(); e.propsDefaults = Object.create(null), di(e, t, r, i); for (const o in e.propsOptions[0]) o in r || (r[o] = void 0); n ? e.props = s ? r : Do(r) : e.type.props ? e.props = r : e.props = i, e.attrs = i } function wl(e, t, n, s) { const { props: r, attrs: i, vnode: { patchFlag: o } } = e, l = V(r), [c] = e.propsOptions; let d = !1; if ((s || o > 0) && !(o & 16)) { if (o & 8) { const u = e.vnode.dynamicProps; for (let h = 0; h < u.length; h++) { let w = u[h]; if (bn(e.emitsOptions, w)) continue; const T = t[w]; if (c) if ($(i, w)) T !== i[w] && (i[w] = T, d = !0); else { const x = ye(w); r[x] = es(c, l, x, T, e, !1) } else T !== i[w] && (i[w] = T, d = !0) } } } else { di(e, t, r, i) && (d = !0); let u; for (const h in l) (!t || !$(t, h) && ((u = rt(h)) === h || !$(t, u))) && (c ? n && (n[h] !== void 0 || n[u] !== void 0) && (r[h] = es(c, l, h, void 0, e, !0)) : delete r[h]); if (i !== l) for (const h in i) (!t || !$(t, h)) && (delete i[h], d = !0) } d && je(e.attrs, "set", "") } function di(e, t, n, s) { const [r, i] = e.propsOptions; let o = !1, l; if (t) for (let c in t) { if (Et(c)) continue; const d = t[c]; let u; r && $(r, u = ye(c)) ? !i || !i.includes(u) ? n[u] = d : (l || (l = {}))[u] = d : bn(e.emitsOptions, c) || (!(c in s) || d !== s[c]) && (s[c] = d, o = !0) } if (i) { const c = V(n), d = l || z; for (let u = 0; u < i.length; u++) { const h = i[u]; n[h] = es(r, c, h, d[h], e, !$(d, h)) } } return o } function es(e, t, n, s, r, i) { const o = e[n]; if (o != null) { const l = $(o, "default"); if (l && s === void 0) { const c = o.default; if (o.type !== Function && !o.skipFactory && j(c)) { const { propsDefaults: d } = r; if (n in d) s = d[n]; else { const u = jt(r); s = d[n] = c.call(null, t), u() } } else s = c; r.ce && r.ce._setProp(n, s) } o[0] && (i && !l ? s = !1 : o[1] && (s === "" || s === rt(n)) && (s = !0)) } return s } const xl = new WeakMap; function hi(e, t, n = !1) { const s = n ? xl : t.propsCache, r = s.get(e); if (r) return r; const i = e.props, o = {}, l = []; let c = !1; if (!j(e)) { const u = h => { c = !0; const [w, T] = hi(h, t, !0); le(o, w), T && l.push(...T) }; !n && t.mixins.length && t.mixins.forEach(u), e.extends && u(e.extends), e.mixins && e.mixins.forEach(u) } if (!i && !c) return G(e) && s.set(e, lt), lt; if (I(i)) for (let u = 0; u < i.length; u++) { const h = ye(i[u]); Ws(h) && (o[h] = z) } else if (i) for (const u in i) { const h = ye(u); if (Ws(h)) { const w = i[u], T = o[h] = I(w) || j(w) ? { type: w } : le({}, w), x = T.type; let R = !1, C = !0; if (I(x)) for (let N = 0; N < x.length; ++N) { const D = x[N], H = j(D) && D.name; if (H === "Boolean") { R = !0; break } else H === "String" && (C = !1) } else R = j(x) && x.name === "Boolean"; T[0] = R, T[1] = C, (R || $(T, "default")) && l.push(h) } } const d = [o, l]; return G(e) && s.set(e, d), d } function Ws(e) { return e[0] !== "$" && !Et(e) } const pi = e => e[0] === "_" || e === "$stable", Rs = e => I(e) ? e.map(ve) : [ve(e)], Sl = (e, t, n) => { if (t._n) return t; const s = Wo((...r) => Rs(t(...r)), n); return s._c = !1, s }, mi = (e, t, n) => { const s = e._ctx; for (const r in e) { if (pi(r)) continue; const i = e[r]; if (j(i)) t[r] = Sl(r, i, s); else if (i != null) { const o = Rs(i); t[r] = () => o } } }, gi = (e, t) => { const n = Rs(t); e.slots.default = () => n }, bi = (e, t, n) => { for (const s in t) (n || s !== "_") && (e[s] = t[s]) }, El = (e, t, n) => { const s = e.slots = ui(); if (e.vnode.shapeFlag & 32) { const r = t._; r ? (bi(s, t, n), n && Pr(s, "_", r, !0)) : mi(t, s) } else t && gi(e, t) }, Tl = (e, t, n) => { const { vnode: s, slots: r } = e; let i = !0, o = z; if (s.shapeFlag & 32) { const l = t._; l ? n && l === 1 ? i = !1 : bi(r, t, n) : (i = !t.$stable, mi(t, r)), o = t } else t && (gi(e, t), o = { default: 1 }); if (i) for (const l in r) !pi(l) && o[l] == null && delete r[l] }, he = jl; function Rl(e) { return Ol(e) } function Ol(e, t) { const n = pn(); n.__VUE__ = !0; const { insert: s, remove: r, patchProp: i, createElement: o, createText: l, createComment: c, setText: d, setElementText: u, parentNode: h, nextSibling: w, setScopeId: T = Le, insertStaticContent: x } = e, R = (f, a, m, y = null, g = null, b = null, O = void 0, E = null, S = !!a.dynamicChildren) => { if (f === a) return; f && !wt(f, a) && (y = kt(f), Ee(f, g, b, !0), f = null), a.patchFlag === -2 && (S = !1, a.dynamicChildren = null); const { type: _, ref: v, shapeFlag: A } = a; switch (_) { case yn: C(f, a, m, y); break; case Lt: N(f, a, m, y); break; case Gt: f == null && D(a, m, y, O); break; case Fe: $t(f, a, m, y, g, b, O, E, S); break; default: A & 1 ? U(f, a, m, y, g, b, O, E, S) : A & 6 ? qt(f, a, m, y, g, b, O, E, S) : (A & 64 || A & 128) && _.process(f, a, m, y, g, b, O, E, S, bt) }v != null && g && rn(v, f && f.ref, b, a || f, !a) }, C = (f, a, m, y) => { if (f == null) s(a.el = l(a.children), m, y); else { const g = a.el = f.el; a.children !== f.children && d(g, a.children) } }, N = (f, a, m, y) => { f == null ? s(a.el = c(a.children || ""), m, y) : a.el = f.el }, D = (f, a, m, y) => { [f.el, f.anchor] = x(f.children, a, m, y, f.el, f.anchor) }, H = ({ el: f, anchor: a }, m, y) => { let g; for (; f && f !== a;)g = w(f), s(f, m, y), f = g; s(a, m, y) }, P = ({ el: f, anchor: a }) => { let m; for (; f && f !== a;)m = w(f), r(f), f = m; r(a) }, U = (f, a, m, y, g, b, O, E, S) => { a.type === "svg" ? O = "svg" : a.type === "math" && (O = "mathml"), f == null ? Q(a, m, y, g, b, O, E, S) : We(f, a, g, b, O, E, S) }, Q = (f, a, m, y, g, b, O, E) => { let S, _; const { props: v, shapeFlag: A, transition: F, dirs: L } = f; if (S = f.el = o(f.type, b, v && v.is, v), A & 8 ? u(S, f.children) : A & 16 && ue(f.children, S, null, y, g, jn(f, b), O, E), L && Xe(f, null, y, "created"), Z(S, f, f.scopeId, O, y), v) { for (const K in v) K !== "value" && !Et(K) && i(S, K, null, v[K], b, y); "value" in v && i(S, "value", null, v.value, b), (_ = v.onVnodeBeforeMount) && Ce(_, y, f) } L && Xe(f, null, y, "beforeMount"); const B = Cl(g, F); B && F.beforeEnter(S), s(S, a, m), ((_ = v && v.onVnodeMounted) || B || L) && he(() => { _ && Ce(_, y, f), B && F.enter(S), L && Xe(f, null, y, "mounted") }, g) }, Z = (f, a, m, y, g) => { if (m && T(f, m), y) for (let b = 0; b < y.length; b++)T(f, y[b]); if (g) { let b = g.subTree; if (a === b || Ei(b.type) && (b.ssContent === a || b.ssFallback === a)) { const O = g.vnode; Z(f, O, O.scopeId, O.slotScopeIds, g.parent) } } }, ue = (f, a, m, y, g, b, O, E, S = 0) => { for (let _ = S; _ < f.length; _++) { const v = f[_] = E ? $e(f[_]) : ve(f[_]); R(null, v, a, m, y, g, b, O, E) } }, We = (f, a, m, y, g, b, O) => { const E = a.el = f.el; let { patchFlag: S, dynamicChildren: _, dirs: v } = a; S |= f.patchFlag & 16; const A = f.props || z, F = a.props || z; let L; if (m && Ye(m, !1), (L = F.onVnodeBeforeUpdate) && Ce(L, m, a, f), v && Xe(a, f, m, "beforeUpdate"), m && Ye(m, !0), (A.innerHTML && F.innerHTML == null || A.textContent && F.textContent == null) && u(E, ""), _ ? ze(f.dynamicChildren, _, E, m, y, jn(a, g), b) : O || k(f, a, E, null, m, y, jn(a, g), b, !1), S > 0) { if (S & 16) mt(E, A, F, m, g); else if (S & 2 && A.class !== F.class && i(E, "class", null, F.class, g), S & 4 && i(E, "style", A.style, F.style, g), S & 8) { const B = a.dynamicProps; for (let K = 0; K < B.length; K++) { const q = B[K], ae = A[q], ce = F[q]; (ce !== ae || q === "value") && i(E, q, ae, ce, g, m) } } S & 1 && f.children !== a.children && u(E, a.children) } else !O && _ == null && mt(E, A, F, m, g); ((L = F.onVnodeUpdated) || v) && he(() => { L && Ce(L, m, a, f), v && Xe(a, f, m, "updated") }, y) }, ze = (f, a, m, y, g, b, O) => { for (let E = 0; E < a.length; E++) { const S = f[E], _ = a[E], v = S.el && (S.type === Fe || !wt(S, _) || S.shapeFlag & 70) ? h(S.el) : m; R(S, _, v, null, y, g, b, O, !0) } }, mt = (f, a, m, y, g) => { if (a !== m) { if (a !== z) for (const b in a) !Et(b) && !(b in m) && i(f, b, a[b], null, g, y); for (const b in m) { if (Et(b)) continue; const O = m[b], E = a[b]; O !== E && b !== "value" && i(f, b, E, O, g, y) } "value" in m && i(f, "value", a.value, m.value, g) } }, $t = (f, a, m, y, g, b, O, E, S) => { const _ = a.el = f ? f.el : l(""), v = a.anchor = f ? f.anchor : l(""); let { patchFlag: A, dynamicChildren: F, slotScopeIds: L } = a; L && (E = E ? E.concat(L) : L), f == null ? (s(_, m, y), s(v, m, y), ue(a.children || [], m, v, g, b, O, E, S)) : A > 0 && A & 64 && F && f.dynamicChildren ? (ze(f.dynamicChildren, F, m, g, b, O, E), (a.key != null || g && a === g.subTree) && yi(f, a, !0)) : k(f, a, m, v, g, b, O, E, S) }, qt = (f, a, m, y, g, b, O, E, S) => { a.slotScopeIds = E, f == null ? a.shapeFlag & 512 ? g.ctx.activate(a, m, y, O, S) : An(a, m, y, g, b, O, S) : vs(f, a, S) }, An = (f, a, m, y, g, b, O) => { const E = f.component = Jl(f, y, g); if (si(f) && (E.ctx.renderer = bt), Gl(E, !1, O), E.asyncDep) { if (g && g.registerDep(E, se, O), !f.el) { const S = E.subTree = xe(Lt); N(null, S, a, m) } } else se(E, f, a, m, g, b, O) }, vs = (f, a, m) => { const y = a.component = f.component; if (Il(f, a, m)) if (y.asyncDep && !y.asyncResolved) { J(y, a, m); return } else y.next = a, y.update(); else a.el = f.el, y.vnode = a }, se = (f, a, m, y, g, b, O) => { const E = () => { if (f.isMounted) { let { next: A, bu: F, u: L, parent: B, vnode: K } = f; { const Re = _i(f); if (Re) { A && (A.el = K.el, J(f, A, O)), Re.asyncDep.then(() => { f.isUnmounted || E() }); return } } let q = A, ae; Ye(f, !1), A ? (A.el = K.el, J(f, A, O)) : A = K, F && Nn(F), (ae = A.props && A.props.onVnodeBeforeUpdate) && Ce(ae, B, A, K), Ye(f, !0); const ce = Js(f), Te = f.subTree; f.subTree = ce, R(Te, ce, h(Te.el), kt(Te), f, g, b), A.el = ce.el, q === null && Hl(f, ce.el), L && he(L, g), (ae = A.props && A.props.onVnodeUpdated) && he(() => Ce(ae, B, A, K), g) } else { let A; const { el: F, props: L } = a, { bm: B, m: K, parent: q, root: ae, type: ce } = f, Te = Ct(a); Ye(f, !1), B && Nn(B), !Te && (A = L && L.onVnodeBeforeMount) && Ce(A, q, a), Ye(f, !0); { ae.ce && ae.ce._injectChildStyle(ce); const Re = f.subTree = Js(f); R(null, Re, m, y, f, g, b), a.el = Re.el } if (K && he(K, g), !Te && (A = L && L.onVnodeMounted)) { const Re = a; he(() => Ce(A, q, Re), g) } (a.shapeFlag & 256 || q && Ct(q.vnode) && q.vnode.shapeFlag & 256) && f.a && he(f.a, g), f.isMounted = !0, a = m = y = null } }; f.scope.on(); const S = f.effect = new Dr(E); f.scope.off(); const _ = f.update = S.run.bind(S), v = f.job = S.runIfDirty.bind(S); v.i = f, v.id = f.uid, S.scheduler = () => Es(v), Ye(f, !0), _() }, J = (f, a, m) => { a.component = f; const y = f.vnode.props; f.vnode = a, f.next = null, wl(f, a.props, y, m), Tl(f, a.children, m), ke(), Bs(f), Ke() }, k = (f, a, m, y, g, b, O, E, S = !1) => { const _ = f && f.children, v = f ? f.shapeFlag : 0, A = a.children, { patchFlag: F, shapeFlag: L } = a; if (F > 0) { if (F & 128) { Vt(_, A, m, y, g, b, O, E, S); return } else if (F & 256) { Je(_, A, m, y, g, b, O, E, S); return } } L & 8 ? (v & 16 && gt(_, g, b), A !== _ && u(m, A)) : v & 16 ? L & 16 ? Vt(_, A, m, y, g, b, O, E, S) : gt(_, g, b, !0) : (v & 8 && u(m, ""), L & 16 && ue(A, m, y, g, b, O, E, S)) }, Je = (f, a, m, y, g, b, O, E, S) => { f = f || lt, a = a || lt; const _ = f.length, v = a.length, A = Math.min(_, v); let F; for (F = 0; F < A; F++) { const L = a[F] = S ? $e(a[F]) : ve(a[F]); R(f[F], L, m, null, g, b, O, E, S) } _ > v ? gt(f, g, b, !0, !1, A) : ue(a, m, y, g, b, O, E, S, A) }, Vt = (f, a, m, y, g, b, O, E, S) => { let _ = 0; const v = a.length; let A = f.length - 1, F = v - 1; for (; _ <= A && _ <= F;) { const L = f[_], B = a[_] = S ? $e(a[_]) : ve(a[_]); if (wt(L, B)) R(L, B, m, null, g, b, O, E, S); else break; _++ } for (; _ <= A && _ <= F;) { const L = f[A], B = a[F] = S ? $e(a[F]) : ve(a[F]); if (wt(L, B)) R(L, B, m, null, g, b, O, E, S); else break; A--, F-- } if (_ > A) { if (_ <= F) { const L = F + 1, B = L < v ? a[L].el : y; for (; _ <= F;)R(null, a[_] = S ? $e(a[_]) : ve(a[_]), m, B, g, b, O, E, S), _++ } } else if (_ > F) for (; _ <= A;)Ee(f[_], g, b, !0), _++; else { const L = _, B = _, K = new Map; for (_ = B; _ <= F; _++) { const de = a[_] = S ? $e(a[_]) : ve(a[_]); de.key != null && K.set(de.key, _) } let q, ae = 0; const ce = F - B + 1; let Te = !1, Re = 0; const yt = new Array(ce); for (_ = 0; _ < ce; _++)yt[_] = 0; for (_ = L; _ <= A; _++) { const de = f[_]; if (ae >= ce) { Ee(de, g, b, !0); continue } let Oe; if (de.key != null) Oe = K.get(de.key); else for (q = B; q <= F; q++)if (yt[q - B] === 0 && wt(de, a[q])) { Oe = q; break } Oe === void 0 ? Ee(de, g, b, !0) : (yt[Oe - B] = _ + 1, Oe >= Re ? Re = Oe : Te = !0, R(de, a[Oe], m, null, g, b, O, E, S), ae++) } const Ms = Te ? Al(yt) : lt; for (q = Ms.length - 1, _ = ce - 1; _ >= 0; _--) { const de = B + _, Oe = a[de], Is = de + 1 < v ? a[de + 1].el : y; yt[_] === 0 ? R(null, Oe, m, Is, g, b, O, E, S) : Te && (q < 0 || _ !== Ms[q] ? Ge(Oe, m, Is, 2) : q--) } } }, Ge = (f, a, m, y, g = null) => { const { el: b, type: O, transition: E, children: S, shapeFlag: _ } = f; if (_ & 6) { Ge(f.component.subTree, a, m, y); return } if (_ & 128) { f.suspense.move(a, m, y); return } if (_ & 64) { O.move(f, a, m, bt); return } if (O === Fe) { s(b, a, m); for (let A = 0; A < S.length; A++)Ge(S[A], a, m, y); s(f.anchor, a, m); return } if (O === Gt) { H(f, a, m); return } if (y !== 2 && _ & 1 && E) if (y === 0) E.beforeEnter(b), s(b, a, m), he(() => E.enter(b), g); else { const { leave: A, delayLeave: F, afterLeave: L } = E, B = () => s(b, a, m), K = () => { A(b, () => { B(), L && L() }) }; F ? F(b, B, K) : K() } else s(b, a, m) }, Ee = (f, a, m, y = !1, g = !1) => { const { type: b, props: O, ref: E, children: S, dynamicChildren: _, shapeFlag: v, patchFlag: A, dirs: F, cacheIndex: L } = f; if (A === -2 && (g = !1), E != null && rn(E, null, m, f, !0), L != null && (a.renderCache[L] = void 0), v & 256) { a.ctx.deactivate(f); return } const B = v & 1 && F, K = !Ct(f); let q; if (K && (q = O && O.onVnodeBeforeUnmount) && Ce(q, a, f), v & 6) eo(f.component, m, y); else { if (v & 128) { f.suspense.unmount(m, y); return } B && Xe(f, null, a, "beforeUnmount"), v & 64 ? f.type.remove(f, a, m, bt, y) : _ && !_.hasOnce && (b !== Fe || A > 0 && A & 64) ? gt(_, a, m, !1, !0) : (b === Fe && A & 384 || !g && v & 16) && gt(S, a, m), y && Ls(f) } (K && (q = O && O.onVnodeUnmounted) || B) && he(() => { q && Ce(q, a, f), B && Xe(f, null, a, "unmounted") }, m) }, Ls = f => { const { type: a, el: m, anchor: y, transition: g } = f; if (a === Fe) { Qi(m, y); return } if (a === Gt) { P(f); return } const b = () => { r(m), g && !g.persisted && g.afterLeave && g.afterLeave() }; if (f.shapeFlag & 1 && g && !g.persisted) { const { leave: O, delayLeave: E } = g, S = () => O(m, b); E ? E(f.el, b, S) : S() } else b() }, Qi = (f, a) => { let m; for (; f !== a;)m = w(f), r(f), f = m; r(a) }, eo = (f, a, m) => { const { bum: y, scope: g, job: b, subTree: O, um: E, m: S, a: _ } = f; zs(S), zs(_), y && Nn(y), g.stop(), b && (b.flags |= 8, Ee(O, f, a, m)), E && he(E, a), he(() => { f.isUnmounted = !0 }, a), a && a.pendingBranch && !a.isUnmounted && f.asyncDep && !f.asyncResolved && f.suspenseId === a.pendingId && (a.deps--, a.deps === 0 && a.resolve()) }, gt = (f, a, m, y = !1, g = !1, b = 0) => { for (let O = b; O < f.length; O++)Ee(f[O], a, m, y, g) }, kt = f => { if (f.shapeFlag & 6) return kt(f.component.subTree); if (f.shapeFlag & 128) return f.suspense.next(); const a = w(f.anchor || f.el), m = a && a[zo]; return m ? w(m) : a }; let Pn = !1; const Ds = (f, a, m) => { f == null ? a._vnode && Ee(a._vnode, null, null, !0) : R(a._vnode || null, f, a, null, null, null, m), a._vnode = f, Pn || (Pn = !0, Bs(), Qr(), Pn = !1) }, bt = { p: R, um: Ee, m: Ge, r: Ls, mt: An, mc: ue, pc: k, pbc: ze, n: kt, o: e }; return { render: Ds, hydrate: void 0, createApp: bl(Ds) } } function jn({ type: e, props: t }, n) { return n === "svg" && e === "foreignObject" || n === "mathml" && e === "annotation-xml" && t && t.encoding && t.encoding.includes("html") ? void 0 : n } function Ye({ effect: e, job: t }, n) { n ? (e.flags |= 32, t.flags |= 4) : (e.flags &= -33, t.flags &= -5) } function Cl(e, t) { return (!e || e && !e.pendingBranch) && t && !t.persisted } function yi(e, t, n = !1) { const s = e.children, r = t.children; if (I(s) && I(r)) for (let i = 0; i < s.length; i++) { const o = s[i]; let l = r[i]; l.shapeFlag & 1 && !l.dynamicChildren && ((l.patchFlag <= 0 || l.patchFlag === 32) && (l = r[i] = $e(r[i]), l.el = o.el), !n && l.patchFlag !== -2 && yi(o, l)), l.type === yn && (l.el = o.el) } } function Al(e) { const t = e.slice(), n = [0]; let s, r, i, o, l; const c = e.length; for (s = 0; s < c; s++) { const d = e[s]; if (d !== 0) { if (r = n[n.length - 1], e[r] < d) { t[s] = r, n.push(s); continue } for (i = 0, o = n.length - 1; i < o;)l = i + o >> 1, e[n[l]] < d ? i = l + 1 : o = l; d < e[n[i]] && (i > 0 && (t[s] = n[i - 1]), n[i] = s) } } for (i = n.length, o = n[i - 1]; i-- > 0;)n[i] = o, o = t[o]; return n } function _i(e) { const t = e.subTree.component; if (t) return t.asyncDep && !t.asyncResolved ? t : _i(t) } function zs(e) { if (e) for (let t = 0; t < e.length; t++)e[t].flags |= 8 } const Pl = Symbol.for("v-scx"), Fl = () => Jt(Pl); function Un(e, t, n) { return wi(e, t, n) } function wi(e, t, n = z) { const { immediate: s, deep: r, flush: i, once: o } = n, l = le({}, n), c = t && s || !t && i !== "post"; let d; if (Mt) { if (i === "sync") { const T = Fl(); d = T.__watcherHandles || (T.__watcherHandles = []) } else if (!c) { const T = () => { }; return T.stop = Le, T.resume = Le, T.pause = Le, T } } const u = te; l.call = (T, x, R) => Me(T, u, x, R); let h = !1; i === "post" ? l.scheduler = T => { he(T, u && u.suspense) } : i !== "sync" && (h = !0, l.scheduler = (T, x) => { x ? T() : Es(T) }), l.augmentJob = T => { t && (T.flags |= 4), h && (T.flags |= 2, u && (T.id = u.uid, T.i = u)) }; const w = $o(e, t, l); return Mt && (d ? d.push(w) : c && w()), w } function Nl(e, t, n) { const s = this.proxy, r = Y(e) ? e.includes(".") ? xi(s, e) : () => s[e] : e.bind(s, s); let i; j(t) ? i = t : (i = t.handler, n = t); const o = jt(this), l = wi(r, i.bind(s), n); return o(), l } function xi(e, t) { const n = t.split("."); return () => { let s = e; for (let r = 0; r < n.length && s; r++)s = s[n[r]]; return s } } const vl = (e, t) => t === "modelValue" || t === "model-value" ? e.modelModifiers : e[`${t}Modifiers`] || e[`${ye(t)}Modifiers`] || e[`${rt(t)}Modifiers`]; function Ll(e, t, ...n) { if (e.isUnmounted) return; const s = e.vnode.props || z; let r = n; const i = t.startsWith("update:"), o = i && vl(s, t.slice(7)); o && (o.trim && (r = n.map(u => Y(u) ? u.trim() : u)), o.number && (r = n.map(oo))); let l, c = s[l = Fn(t)] || s[l = Fn(ye(t))]; !c && i && (c = s[l = Fn(rt(t))]), c && Me(c, e, 6, r); const d = s[l + "Once"]; if (d) { if (!e.emitted) e.emitted = {}; else if (e.emitted[l]) return; e.emitted[l] = !0, Me(d, e, 6, r) } } function Si(e, t, n = !1) { const s = t.emitsCache, r = s.get(e); if (r !== void 0) return r; const i = e.emits; let o = {}, l = !1; if (!j(e)) { const c = d => { const u = Si(d, t, !0); u && (l = !0, le(o, u)) }; !n && t.mixins.length && t.mixins.forEach(c), e.extends && c(e.extends), e.mixins && e.mixins.forEach(c) } return !i && !l ? (G(e) && s.set(e, null), null) : (I(i) ? i.forEach(c => o[c] = null) : le(o, i), G(e) && s.set(e, o), o) } function bn(e, t) { return !e || !un(t) ? !1 : (t = t.slice(2).replace(/Once$/, ""), $(e, t[0].toLowerCase() + t.slice(1)) || $(e, rt(t)) || $(e, t)) } function Js(e) { const { type: t, vnode: n, proxy: s, withProxy: r, propsOptions: [i], slots: o, attrs: l, emit: c, render: d, renderCache: u, props: h, data: w, setupState: T, ctx: x, inheritAttrs: R } = e, C = sn(e); let N, D; try { if (n.shapeFlag & 4) { const P = r || s, U = P; N = ve(d.call(U, P, u, h, T, w, x)), D = l } else { const P = t; N = ve(P.length > 1 ? P(h, { attrs: l, slots: o, emit: c }) : P(h, null)), D = t.props ? l : Dl(l) } } catch (P) { Pt.length = 0, mn(P, e, 1), N = xe(Lt) } let H = N; if (D && R !== !1) { const P = Object.keys(D), { shapeFlag: U } = H; P.length && U & 7 && (i && P.some(us) && (D = Ml(D, i)), H = dt(H, D, !1, !0)) } return n.dirs && (H = dt(H, null, !1, !0), H.dirs = H.dirs ? H.dirs.concat(n.dirs) : n.dirs), n.transition && Ts(H, n.transition), N = H, sn(C), N } const Dl = e => { let t; for (const n in e) (n === "class" || n === "style" || un(n)) && ((t || (t = {}))[n] = e[n]); return t }, Ml = (e, t) => { const n = {}; for (const s in e) (!us(s) || !(s.slice(9) in t)) && (n[s] = e[s]); return n }; function Il(e, t, n) { const { props: s, children: r, component: i } = e, { props: o, children: l, patchFlag: c } = t, d = i.emitsOptions; if (t.dirs || t.transition) return !0; if (n && c >= 0) { if (c & 1024) return !0; if (c & 16) return s ? Gs(s, o, d) : !!o; if (c & 8) { const u = t.dynamicProps; for (let h = 0; h < u.length; h++) { const w = u[h]; if (o[w] !== s[w] && !bn(d, w)) return !0 } } } else return (r || l) && (!l || !l.$stable) ? !0 : s === o ? !1 : s ? o ? Gs(s, o, d) : !0 : !!o; return !1 } function Gs(e, t, n) { const s = Object.keys(t); if (s.length !== Object.keys(e).length) return !0; for (let r = 0; r < s.length; r++) { const i = s[r]; if (t[i] !== e[i] && !bn(n, i)) return !0 } return !1 } function Hl({ vnode: e, parent: t }, n) { for (; t;) { const s = t.subTree; if (s.suspense && s.suspense.activeBranch === e && (s.el = e.el), s === e) (e = t.vnode).el = n, t = t.parent; else break } } const Ei = e => e.__isSuspense; function jl(e, t) { t && t.pendingBranch ? I(e) ? t.effects.push(...e) : t.effects.push(e) : Ko(e) } const Fe = Symbol.for("v-fgt"), yn = Symbol.for("v-txt"), Lt = Symbol.for("v-cmt"), Gt = Symbol.for("v-stc"), Pt = []; let ge = null; function _n(e = !1) { Pt.push(ge = e ? null : []) } function Ul() { Pt.pop(), ge = Pt[Pt.length - 1] || null } let Dt = 1; function Xs(e, t = !1) { Dt += e, e < 0 && ge && t && (ge.hasOnce = !0) } function Bl(e) { return e.dynamicChildren = Dt > 0 ? ge || lt : null, Ul(), Dt > 0 && ge && ge.push(e), e } function wn(e, t, n, s, r, i) { return Bl(Ne(e, t, n, s, r, i, !0)) } function Ti(e) { return e ? e.__v_isVNode === !0 : !1 } function wt(e, t) { return e.type === t.type && e.key === t.key } const Ri = ({ key: e }) => e ?? null, Xt = ({ ref: e, ref_key: t, ref_for: n }) => (typeof e == "number" && (e = "" + e), e != null ? Y(e) || oe(e) || j(e) ? { i: _e, r: e, k: t, f: !!n } : e : null); function Ne(e, t = null, n = null, s = 0, r = null, i = e === Fe ? 0 : 1, o = !1, l = !1) { const c = { __v_isVNode: !0, __v_skip: !0, type: e, props: t, key: t && Ri(t), ref: t && Xt(t), scopeId: ti, slotScopeIds: null, children: n, component: null, suspense: null, ssContent: null, ssFallback: null, dirs: null, transition: null, el: null, anchor: null, target: null, targetStart: null, targetAnchor: null, staticCount: 0, shapeFlag: i, patchFlag: s, dynamicProps: r, dynamicChildren: null, appContext: null, ctx: _e }; return l ? (Os(c, n), i & 128 && e.normalize(c)) : n && (c.shapeFlag |= Y(n) ? 8 : 16), Dt > 0 && !o && ge && (c.patchFlag > 0 || i & 6) && c.patchFlag !== 32 && ge.push(c), c } const xe = $l; function $l(e, t = null, n = null, s = 0, r = null, i = !1) { if ((!e || e === cl) && (e = Lt), Ti(e)) { const l = dt(e, t, !0); return n && Os(l, n), Dt > 0 && !i && ge && (l.shapeFlag & 6 ? ge[ge.indexOf(e)] = l : ge.push(l)), l.patchFlag = -2, l } if (ec(e) && (e = e.__vccOpts), t) { t = ql(t); let { class: l, style: c } = t; l && !Y(l) && (t.class = ps(l)), G(c) && (Ss(c) && !I(c) && (c = le({}, c)), t.style = hs(c)) } const o = Y(e) ? 1 : Ei(e) ? 128 : Jo(e) ? 64 : G(e) ? 4 : j(e) ? 2 : 0; return Ne(e, t, n, s, r, o, i, !0) } function ql(e) { return e ? Ss(e) || ai(e) ? le({}, e) : e : null } function dt(e, t, n = !1, s = !1) { const { props: r, ref: i, patchFlag: o, children: l, transition: c } = e, d = t ? Kl(r || {}, t) : r, u = { __v_isVNode: !0, __v_skip: !0, type: e.type, props: d, key: d && Ri(d), ref: t && t.ref ? n && i ? I(i) ? i.concat(Xt(t)) : [i, Xt(t)] : Xt(t) : i, scopeId: e.scopeId, slotScopeIds: e.slotScopeIds, children: l, target: e.target, targetStart: e.targetStart, targetAnchor: e.targetAnchor, staticCount: e.staticCount, shapeFlag: e.shapeFlag, patchFlag: t && e.type !== Fe ? o === -1 ? 16 : o | 16 : o, dynamicProps: e.dynamicProps, dynamicChildren: e.dynamicChildren, appContext: e.appContext, dirs: e.dirs, transition: c, component: e.component, suspense: e.suspense, ssContent: e.ssContent && dt(e.ssContent), ssFallback: e.ssFallback && dt(e.ssFallback), el: e.el, anchor: e.anchor, ctx: e.ctx, ce: e.ce }; return c && s && Ts(u, c.clone(u)), u } function Vl(e = " ", t = 0) { return xe(yn, null, e, t) } function kl(e, t) { const n = xe(Gt, null, e); return n.staticCount = t, n } function ve(e) { return e == null || typeof e == "boolean" ? xe(Lt) : I(e) ? xe(Fe, null, e.slice()) : Ti(e) ? $e(e) : xe(yn, null, String(e)) } function $e(e) { return e.el === null && e.patchFlag !== -1 || e.memo ? e : dt(e) } function Os(e, t) { let n = 0; const { shapeFlag: s } = e; if (t == null) t = null; else if (I(t)) n = 16; else if (typeof t == "object") if (s & 65) { const r = t.default; r && (r._c && (r._d = !1), Os(e, r()), r._c && (r._d = !0)); return } else { n = 32; const r = t._; !r && !ai(t) ? t._ctx = _e : r === 3 && _e && (_e.slots._ === 1 ? t._ = 1 : (t._ = 2, e.patchFlag |= 1024)) } else j(t) ? (t = { default: t, _ctx: _e }, n = 32) : (t = String(t), s & 64 ? (n = 16, t = [Vl(t)]) : n = 8); e.children = t, e.shapeFlag |= n } function Kl(...e) { const t = {}; for (let n = 0; n < e.length; n++) { const s = e[n]; for (const r in s) if (r === "class") t.class !== s.class && (t.class = ps([t.class, s.class])); else if (r === "style") t.style = hs([t.style, s.style]); else if (un(r)) { const i = t[r], o = s[r]; o && i !== o && !(I(i) && i.includes(o)) && (t[r] = i ? [].concat(i, o) : o) } else r !== "" && (t[r] = s[r]) } return t } function Ce(e, t, n, s = null) { Me(e, t, 7, [n, s]) } const Wl = ci(); let zl = 0; function Jl(e, t, n) { const s = e.type, r = (t ? t.appContext : e.appContext) || Wl, i = { uid: zl++, vnode: e, type: s, parent: t, appContext: r, root: null, next: null, subTree: null, effect: null, update: null, job: null, scope: new po(!0), render: null, proxy: null, exposed: null, exposeProxy: null, withProxy: null, provides: t ? t.provides : Object.create(r.provides), ids: t ? t.ids : ["", 0, 0], accessCache: null, renderCache: [], components: null, directives: null, propsOptions: hi(s, r), emitsOptions: Si(s, r), emit: null, emitted: null, propsDefaults: z, inheritAttrs: s.inheritAttrs, ctx: z, data: z, props: z, attrs: z, slots: z, refs: z, setupState: z, setupContext: null, suspense: n, suspenseId: n ? n.pendingId : 0, asyncDep: null, asyncResolved: !1, isMounted: !1, isUnmounted: !1, isDeactivated: !1, bc: null, c: null, bm: null, m: null, bu: null, u: null, um: null, bum: null, da: null, a: null, rtg: null, rtc: null, ec: null, sp: null }; return i.ctx = { _: i }, i.root = t ? t.root : i, i.emit = Ll.bind(null, i), e.ce && e.ce(i), i } let te = null, ln, ts; { const e = pn(), t = (n, s) => { let r; return (r = e[n]) || (r = e[n] = []), r.push(s), i => { r.length > 1 ? r.forEach(o => o(i)) : r[0](i) } }; ln = t("__VUE_INSTANCE_SETTERS__", n => te = n), ts = t("__VUE_SSR_SETTERS__", n => Mt = n) } const jt = e => { const t = te; return ln(e), e.scope.on(), () => { e.scope.off(), ln(t) } }, Ys = () => { te && te.scope.off(), ln(null) }; function Oi(e) { return e.vnode.shapeFlag & 4 } let Mt = !1; function Gl(e, t = !1, n = !1) { t && ts(t); const { props: s, children: r } = e.vnode, i = Oi(e); _l(e, s, i, t), El(e, r, n); const o = i ? Xl(e, t) : void 0; return t && ts(!1), o } function Xl(e, t) { const n = e.type; e.accessCache = Object.create(null), e.proxy = new Proxy(e.ctx, ul); const { setup: s } = n; if (s) { ke(); const r = e.setupContext = s.length > 1 ? Zl(e) : null, i = jt(e), o = Ht(s, e, 0, [e.props, r]), l = Or(o); if (Ke(), i(), (l || e.sp) && !Ct(e) && ni(e), l) { if (o.then(Ys, Ys), t) return o.then(c => { Zs(e, c) }).catch(c => { mn(c, e, 0) }); e.asyncDep = o } else Zs(e, o) } else Ci(e) } function Zs(e, t, n) { j(t) ? e.type.__ssrInlineRender ? e.ssrRender = t : e.render = t : G(t) && (e.setupState = Xr(t)), Ci(e) } function Ci(e, t, n) { const s = e.type; e.render || (e.render = s.render || Le); { const r = jt(e); ke(); try { al(e) } finally { Ke(), r() } } } const Yl = { get(e, t) { return ee(e, "get", ""), e[t] } }; function Zl(e) { const t = n => { e.exposed = n || {} }; return { attrs: new Proxy(e.attrs, Yl), slots: e.slots, emit: e.emit, expose: t } } function Cs(e) { return e.exposed ? e.exposeProxy || (e.exposeProxy = new Proxy(Xr(Mo(e.exposed)), { get(t, n) { if (n in t) return t[n]; if (n in At) return At[n](e) }, has(t, n) { return n in t || n in At } })) : e.proxy } function Ql(e, t = !0) { return j(e) ? e.displayName || e.name : e.name || t && e.__name } function ec(e) { return j(e) && "__vccOpts" in e } const tc = (e, t) => Uo(e, t, Mt), nc = "3.5.13";/**
* @vue/runtime-dom v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/let ns; const Qs = typeof window < "u" && window.trustedTypes; if (Qs) try { ns = Qs.createPolicy("vue", { createHTML: e => e }) } catch { } const Ai = ns ? e => ns.createHTML(e) : e => e, sc = "http://www.w3.org/2000/svg", rc = "http://www.w3.org/1998/Math/MathML", He = typeof document < "u" ? document : null, er = He && He.createElement("template"), ic = { insert: (e, t, n) => { t.insertBefore(e, n || null) }, remove: e => { const t = e.parentNode; t && t.removeChild(e) }, createElement: (e, t, n, s) => { const r = t === "svg" ? He.createElementNS(sc, e) : t === "mathml" ? He.createElementNS(rc, e) : n ? He.createElement(e, { is: n }) : He.createElement(e); return e === "select" && s && s.multiple != null && r.setAttribute("multiple", s.multiple), r }, createText: e => He.createTextNode(e), createComment: e => He.createComment(e), setText: (e, t) => { e.nodeValue = t }, setElementText: (e, t) => { e.textContent = t }, parentNode: e => e.parentNode, nextSibling: e => e.nextSibling, querySelector: e => He.querySelector(e), setScopeId(e, t) { e.setAttribute(t, "") }, insertStaticContent(e, t, n, s, r, i) { const o = n ? n.previousSibling : t.lastChild; if (r && (r === i || r.nextSibling)) for (; t.insertBefore(r.cloneNode(!0), n), !(r === i || !(r = r.nextSibling));); else { er.innerHTML = Ai(s === "svg" ? `<svg>${e}</svg>` : s === "mathml" ? `<math>${e}</math>` : e); const l = er.content; if (s === "svg" || s === "mathml") { const c = l.firstChild; for (; c.firstChild;)l.appendChild(c.firstChild); l.removeChild(c) } t.insertBefore(l, n) } return [o ? o.nextSibling : t.firstChild, n ? n.previousSibling : t.lastChild] } }, oc = Symbol("_vtc"); function lc(e, t, n) { const s = e[oc]; s && (t = (t ? [t, ...s] : [...s]).join(" ")), t == null ? e.removeAttribute("class") : n ? e.setAttribute("class", t) : e.className = t } const tr = Symbol("_vod"), cc = Symbol("_vsh"), fc = Symbol(""), uc = /(^|;)\s*display\s*:/; function ac(e, t, n) { const s = e.style, r = Y(n); let i = !1; if (n && !r) { if (t) if (Y(t)) for (const o of t.split(";")) { const l = o.slice(0, o.indexOf(":")).trim(); n[l] == null && Yt(s, l, "") } else for (const o in t) n[o] == null && Yt(s, o, ""); for (const o in n) o === "display" && (i = !0), Yt(s, o, n[o]) } else if (r) { if (t !== n) { const o = s[fc]; o && (n += ";" + o), s.cssText = n, i = uc.test(n) } } else t && e.removeAttribute("style"); tr in e && (e[tr] = i ? s.display : "", e[cc] && (s.display = "none")) } const nr = /\s*!important$/; function Yt(e, t, n) { if (I(n)) n.forEach(s => Yt(e, t, s)); else if (n == null && (n = ""), t.startsWith("--")) e.setProperty(t, n); else { const s = dc(e, t); nr.test(n) ? e.setProperty(rt(s), n.replace(nr, ""), "important") : e[s] = n } } const sr = ["Webkit", "Moz", "ms"], Bn = {}; function dc(e, t) { const n = Bn[t]; if (n) return n; let s = ye(t); if (s !== "filter" && s in e) return Bn[t] = s; s = hn(s); for (let r = 0; r < sr.length; r++) { const i = sr[r] + s; if (i in e) return Bn[t] = i } return t } const rr = "http://www.w3.org/1999/xlink"; function ir(e, t, n, s, r, i = ho(t)) { s && t.startsWith("xlink:") ? n == null ? e.removeAttributeNS(rr, t.slice(6, t.length)) : e.setAttributeNS(rr, t, n) : n == null || i && !Fr(n) ? e.removeAttribute(t) : e.setAttribute(t, i ? "" : Ve(n) ? String(n) : n) } function or(e, t, n, s, r) { if (t === "innerHTML" || t === "textContent") { n != null && (e[t] = t === "innerHTML" ? Ai(n) : n); return } const i = e.tagName; if (t === "value" && i !== "PROGRESS" && !i.includes("-")) { const l = i === "OPTION" ? e.getAttribute("value") || "" : e.value, c = n == null ? e.type === "checkbox" ? "on" : "" : String(n); (l !== c || !("_value" in e)) && (e.value = c), n == null && e.removeAttribute(t), e._value = n; return } let o = !1; if (n === "" || n == null) { const l = typeof e[t]; l === "boolean" ? n = Fr(n) : n == null && l === "string" ? (n = "", o = !0) : l === "number" && (n = 0, o = !0) } try { e[t] = n } catch { } o && e.removeAttribute(r || t) } function hc(e, t, n, s) { e.addEventListener(t, n, s) } function pc(e, t, n, s) { e.removeEventListener(t, n, s) } const lr = Symbol("_vei"); function mc(e, t, n, s, r = null) { const i = e[lr] || (e[lr] = {}), o = i[t]; if (s && o) o.value = s; else { const [l, c] = gc(t); if (s) { const d = i[t] = _c(s, r); hc(e, l, d, c) } else o && (pc(e, l, o, c), i[t] = void 0) } } const cr = /(?:Once|Passive|Capture)$/; function gc(e) { let t; if (cr.test(e)) { t = {}; let s; for (; s = e.match(cr);)e = e.slice(0, e.length - s[0].length), t[s[0].toLowerCase()] = !0 } return [e[2] === ":" ? e.slice(3) : rt(e.slice(2)), t] } let $n = 0; const bc = Promise.resolve(), yc = () => $n || (bc.then(() => $n = 0), $n = Date.now()); function _c(e, t) { const n = s => { if (!s._vts) s._vts = Date.now(); else if (s._vts <= n.attached) return; Me(wc(s, n.value), t, 5, [s]) }; return n.value = e, n.attached = yc(), n } function wc(e, t) { if (I(t)) { const n = e.stopImmediatePropagation; return e.stopImmediatePropagation = () => { n.call(e), e._stopped = !0 }, t.map(s => r => !r._stopped && s && s(r)) } else return t } const fr = e => e.charCodeAt(0) === 111 && e.charCodeAt(1) === 110 && e.charCodeAt(2) > 96 && e.charCodeAt(2) < 123, xc = (e, t, n, s, r, i) => { const o = r === "svg"; t === "class" ? lc(e, s, o) : t === "style" ? ac(e, n, s) : un(t) ? us(t) || mc(e, t, n, s, i) : (t[0] === "." ? (t = t.slice(1), !0) : t[0] === "^" ? (t = t.slice(1), !1) : Sc(e, t, s, o)) ? (or(e, t, s), !e.tagName.includes("-") && (t === "value" || t === "checked" || t === "selected") && ir(e, t, s, o, i, t !== "value")) : e._isVueCE && (/[A-Z]/.test(t) || !Y(s)) ? or(e, ye(t), s, i, t) : (t === "true-value" ? e._trueValue = s : t === "false-value" && (e._falseValue = s), ir(e, t, s, o)) }; function Sc(e, t, n, s) { if (s) return !!(t === "innerHTML" || t === "textContent" || t in e && fr(t) && j(n)); if (t === "spellcheck" || t === "draggable" || t === "translate" || t === "form" || t === "list" && e.tagName === "INPUT" || t === "type" && e.tagName === "TEXTAREA") return !1; if (t === "width" || t === "height") { const r = e.tagName; if (r === "IMG" || r === "VIDEO" || r === "CANVAS" || r === "SOURCE") return !1 } return fr(t) && Y(n) ? !1 : t in e } const Ec = le({ patchProp: xc }, ic); let ur; function Tc() { return ur || (ur = Rl(Ec)) } const Rc = (...e) => { const t = Tc().createApp(...e), { mount: n } = t; return t.mount = s => { const r = Cc(s); if (!r) return; const i = t._component; !j(i) && !i.render && !i.template && (i.template = r.innerHTML), r.nodeType === 1 && (r.textContent = ""); const o = n(r, !1, Oc(r)); return r instanceof Element && (r.removeAttribute("v-cloak"), r.setAttribute("data-v-app", "")), o }, t }; function Oc(e) { if (e instanceof SVGElement) return "svg"; if (typeof MathMLElement == "function" && e instanceof MathMLElement) return "mathml" } function Cc(e) { return Y(e) ? document.querySelector(e) : e } const xn = (e, t) => { const n = e.__vccOpts || e; for (const [s, r] of t) n[s] = r; return n }, Ac = {}, Pc = { class: "top-wrap", style: { position: "absolute", top: "1vh", width: "100%", "z-index": "999" } }; function Fc(e, t) { return _n(), wn("div", Pc, t[0] || (t[0] = [kl('<div class="container"><div class="row" style="margin-top:30px;"><div class="col"><img src="./assets/logo.png"></div><div class="col"><div class="float-right" style="padding-top:0px;"><a class="btn btn-primary btn-filled btn-xs" href="https://github.com/egotong/nows">开源</a></div></div></div></div>', 1)])) } const Nc = xn(Ac, [["render", Fc]]), vc = { data() { return {} }, mounted() { console.log("ChickenMain 加载完毕") }, props: { messsage: { type: String } } }, Lc = { class: "main-wrapper", style: { position: "relative", top: "-6vh" } }, Dc = { class: "container main-sentence justify-content-center text-center" }, Mc = { id: "sentence", style: { "font-size": "2rem" } }; function Ic(e, t, n, s, r, i) { return _n(), wn("div", Lc, [Ne("div", Dc, [Ne("span", Mc, vr(n.messsage), 1)])]) } const Hc = xn(vc, [["render", Ic]]); function Pi(e, t) { return function () { return e.apply(t, arguments) } } const { toString: jc } = Object.prototype, { getPrototypeOf: As } = Object, Sn = (e => t => { const n = jc.call(t); return e[n] || (e[n] = n.slice(8, -1).toLowerCase()) })(Object.create(null)), Se = e => (e = e.toLowerCase(), t => Sn(t) === e), En = e => t => typeof t === e, { isArray: ht } = Array, It = En("undefined"); function Uc(e) { return e !== null && !It(e) && e.constructor !== null && !It(e.constructor) && be(e.constructor.isBuffer) && e.constructor.isBuffer(e) } const Fi = Se("ArrayBuffer"); function Bc(e) { let t; return typeof ArrayBuffer < "u" && ArrayBuffer.isView ? t = ArrayBuffer.isView(e) : t = e && e.buffer && Fi(e.buffer), t } const $c = En("string"), be = En("function"), Ni = En("number"), Tn = e => e !== null && typeof e == "object", qc = e => e === !0 || e === !1, Zt = e => { if (Sn(e) !== "object") return !1; const t = As(e); return (t === null || t === Object.prototype || Object.getPrototypeOf(t) === null) && !(Symbol.toStringTag in e) && !(Symbol.iterator in e) }, Vc = Se("Date"), kc = Se("File"), Kc = Se("Blob"), Wc = Se("FileList"), zc = e => Tn(e) && be(e.pipe), Jc = e => { let t; return e && (typeof FormData == "function" && e instanceof FormData || be(e.append) && ((t = Sn(e)) === "formdata" || t === "object" && be(e.toString) && e.toString() === "[object FormData]")) }, Gc = Se("URLSearchParams"), [Xc, Yc, Zc, Qc] = ["ReadableStream", "Request", "Response", "Headers"].map(Se), ef = e => e.trim ? e.trim() : e.replace(/^[\s\uFEFF\xA0]+|[\s\uFEFF\xA0]+$/g, ""); function Ut(e, t, { allOwnKeys: n = !1 } = {}) { if (e === null || typeof e > "u") return; let s, r; if (typeof e != "object" && (e = [e]), ht(e)) for (s = 0, r = e.length; s < r; s++)t.call(null, e[s], s, e); else { const i = n ? Object.getOwnPropertyNames(e) : Object.keys(e), o = i.length; let l; for (s = 0; s < o; s++)l = i[s], t.call(null, e[l], l, e) } } function vi(e, t) { t = t.toLowerCase(); const n = Object.keys(e); let s = n.length, r; for (; s-- > 0;)if (r = n[s], t === r.toLowerCase()) return r; return null } const Qe = typeof globalThis < "u" ? globalThis : typeof self < "u" ? self : typeof window < "u" ? window : global, Li = e => !It(e) && e !== Qe; function ss() { const { caseless: e } = Li(this) && this || {}, t = {}, n = (s, r) => { const i = e && vi(t, r) || r; Zt(t[i]) && Zt(s) ? t[i] = ss(t[i], s) : Zt(s) ? t[i] = ss({}, s) : ht(s) ? t[i] = s.slice() : t[i] = s }; for (let s = 0, r = arguments.length; s < r; s++)arguments[s] && Ut(arguments[s], n); return t } const tf = (e, t, n, { allOwnKeys: s } = {}) => (Ut(t, (r, i) => { n && be(r) ? e[i] = Pi(r, n) : e[i] = r }, { allOwnKeys: s }), e), nf = e => (e.charCodeAt(0) === 65279 && (e = e.slice(1)), e), sf = (e, t, n, s) => { e.prototype = Object.create(t.prototype, s), e.prototype.constructor = e, Object.defineProperty(e, "super", { value: t.prototype }), n && Object.assign(e.prototype, n) }, rf = (e, t, n, s) => { let r, i, o; const l = {}; if (t = t || {}, e == null) return t; do { for (r = Object.getOwnPropertyNames(e), i = r.length; i-- > 0;)o = r[i], (!s || s(o, e, t)) && !l[o] && (t[o] = e[o], l[o] = !0); e = n !== !1 && As(e) } while (e && (!n || n(e, t)) && e !== Object.prototype); return t }, of = (e, t, n) => { e = String(e), (n === void 0 || n > e.length) && (n = e.length), n -= t.length; const s = e.indexOf(t, n); return s !== -1 && s === n }, lf = e => { if (!e) return null; if (ht(e)) return e; let t = e.length; if (!Ni(t)) return null; const n = new Array(t); for (; t-- > 0;)n[t] = e[t]; return n }, cf = (e => t => e && t instanceof e)(typeof Uint8Array < "u" && As(Uint8Array)), ff = (e, t) => { const s = (e && e[Symbol.iterator]).call(e); let r; for (; (r = s.next()) && !r.done;) { const i = r.value; t.call(e, i[0], i[1]) } }, uf = (e, t) => { let n; const s = []; for (; (n = e.exec(t)) !== null;)s.push(n); return s }, af = Se("HTMLFormElement"), df = e => e.toLowerCase().replace(/[-_\s]([a-z\d])(\w*)/g, function (n, s, r) { return s.toUpperCase() + r }), ar = (({ hasOwnProperty: e }) => (t, n) => e.call(t, n))(Object.prototype), hf = Se("RegExp"), Di = (e, t) => { const n = Object.getOwnPropertyDescriptors(e), s = {}; Ut(n, (r, i) => { let o; (o = t(r, i, e)) !== !1 && (s[i] = o || r) }), Object.defineProperties(e, s) }, pf = e => { Di(e, (t, n) => { if (be(e) && ["arguments", "caller", "callee"].indexOf(n) !== -1) return !1; const s = e[n]; if (be(s)) { if (t.enumerable = !1, "writable" in t) { t.writable = !1; return } t.set || (t.set = () => { throw Error("Can not rewrite read-only method '" + n + "'") }) } }) }, mf = (e, t) => { const n = {}, s = r => { r.forEach(i => { n[i] = !0 }) }; return ht(e) ? s(e) : s(String(e).split(t)), n }, gf = () => { }, bf = (e, t) => e != null && Number.isFinite(e = +e) ? e : t, qn = "abcdefghijklmnopqrstuvwxyz", dr = "0123456789", Mi = { DIGIT: dr, ALPHA: qn, ALPHA_DIGIT: qn + qn.toUpperCase() + dr }, yf = (e = 16, t = Mi.ALPHA_DIGIT) => { let n = ""; const { length: s } = t; for (; e--;)n += t[Math.random() * s | 0]; return n }; function _f(e) { return !!(e && be(e.append) && e[Symbol.toStringTag] === "FormData" && e[Symbol.iterator]) } const wf = e => { const t = new Array(10), n = (s, r) => { if (Tn(s)) { if (t.indexOf(s) >= 0) return; if (!("toJSON" in s)) { t[r] = s; const i = ht(s) ? [] : {}; return Ut(s, (o, l) => { const c = n(o, r + 1); !It(c) && (i[l] = c) }), t[r] = void 0, i } } return s }; return n(e, 0) }, xf = Se("AsyncFunction"), Sf = e => e && (Tn(e) || be(e)) && be(e.then) && be(e.catch), Ii = ((e, t) => e ? setImmediate : t ? ((n, s) => (Qe.addEventListener("message", ({ source: r, data: i }) => { r === Qe && i === n && s.length && s.shift()() }, !1), r => { s.push(r), Qe.postMessage(n, "*") }))(`axios@${Math.random()}`, []) : n => setTimeout(n))(typeof setImmediate == "function", be(Qe.postMessage)), Ef = typeof queueMicrotask < "u" ? queueMicrotask.bind(Qe) : typeof process < "u" && process.nextTick || Ii, p = { isArray: ht, isArrayBuffer: Fi, isBuffer: Uc, isFormData: Jc, isArrayBufferView: Bc, isString: $c, isNumber: Ni, isBoolean: qc, isObject: Tn, isPlainObject: Zt, isReadableStream: Xc, isRequest: Yc, isResponse: Zc, isHeaders: Qc, isUndefined: It, isDate: Vc, isFile: kc, isBlob: Kc, isRegExp: hf, isFunction: be, isStream: zc, isURLSearchParams: Gc, isTypedArray: cf, isFileList: Wc, forEach: Ut, merge: ss, extend: tf, trim: ef, stripBOM: nf, inherits: sf, toFlatObject: rf, kindOf: Sn, kindOfTest: Se, endsWith: of, toArray: lf, forEachEntry: ff, matchAll: uf, isHTMLForm: af, hasOwnProperty: ar, hasOwnProp: ar, reduceDescriptors: Di, freezeMethods: pf, toObjectSet: mf, toCamelCase: df, noop: gf, toFiniteNumber: bf, findKey: vi, global: Qe, isContextDefined: Li, ALPHABET: Mi, generateString: yf, isSpecCompliantForm: _f, toJSONObject: wf, isAsyncFn: xf, isThenable: Sf, setImmediate: Ii, asap: Ef }; function M(e, t, n, s, r) { Error.call(this), Error.captureStackTrace ? Error.captureStackTrace(this, this.constructor) : this.stack = new Error().stack, this.message = e, this.name = "AxiosError", t && (this.code = t), n && (this.config = n), s && (this.request = s), r && (this.response = r, this.status = r.status ? r.status : null) } p.inherits(M, Error, { toJSON: function () { return { message: this.message, name: this.name, description: this.description, number: this.number, fileName: this.fileName, lineNumber: this.lineNumber, columnNumber: this.columnNumber, stack: this.stack, config: p.toJSONObject(this.config), code: this.code, status: this.status } } }); const Hi = M.prototype, ji = {};["ERR_BAD_OPTION_VALUE", "ERR_BAD_OPTION", "ECONNABORTED", "ETIMEDOUT", "ERR_NETWORK", "ERR_FR_TOO_MANY_REDIRECTS", "ERR_DEPRECATED", "ERR_BAD_RESPONSE", "ERR_BAD_REQUEST", "ERR_CANCELED", "ERR_NOT_SUPPORT", "ERR_INVALID_URL"].forEach(e => { ji[e] = { value: e } }); Object.defineProperties(M, ji); Object.defineProperty(Hi, "isAxiosError", { value: !0 }); M.from = (e, t, n, s, r, i) => { const o = Object.create(Hi); return p.toFlatObject(e, o, function (c) { return c !== Error.prototype }, l => l !== "isAxiosError"), M.call(o, e.message, t, n, s, r), o.cause = e, o.name = e.name, i && Object.assign(o, i), o }; const Tf = null; function rs(e) { return p.isPlainObject(e) || p.isArray(e) } function Ui(e) { return p.endsWith(e, "[]") ? e.slice(0, -2) : e } function hr(e, t, n) { return e ? e.concat(t).map(function (r, i) { return r = Ui(r), !n && i ? "[" + r + "]" : r }).join(n ? "." : "") : t } function Rf(e) { return p.isArray(e) && !e.some(rs) } const Of = p.toFlatObject(p, {}, null, function (t) { return /^is[A-Z]/.test(t) }); function Rn(e, t, n) { if (!p.isObject(e)) throw new TypeError("target must be an object"); t = t || new FormData, n = p.toFlatObject(n, { metaTokens: !0, dots: !1, indexes: !1 }, !1, function (R, C) { return !p.isUndefined(C[R]) }); const s = n.metaTokens, r = n.visitor || u, i = n.dots, o = n.indexes, c = (n.Blob || typeof Blob < "u" && Blob) && p.isSpecCompliantForm(t); if (!p.isFunction(r)) throw new TypeError("visitor must be a function"); function d(x) { if (x === null) return ""; if (p.isDate(x)) return x.toISOString(); if (!c && p.isBlob(x)) throw new M("Blob is not supported. Use a Buffer instead."); return p.isArrayBuffer(x) || p.isTypedArray(x) ? c && typeof Blob == "function" ? new Blob([x]) : Buffer.from(x) : x } function u(x, R, C) { let N = x; if (x && !C && typeof x == "object") { if (p.endsWith(R, "{}")) R = s ? R : R.slice(0, -2), x = JSON.stringify(x); else if (p.isArray(x) && Rf(x) || (p.isFileList(x) || p.endsWith(R, "[]")) && (N = p.toArray(x))) return R = Ui(R), N.forEach(function (H, P) { !(p.isUndefined(H) || H === null) && t.append(o === !0 ? hr([R], P, i) : o === null ? R : R + "[]", d(H)) }), !1 } return rs(x) ? !0 : (t.append(hr(C, R, i), d(x)), !1) } const h = [], w = Object.assign(Of, { defaultVisitor: u, convertValue: d, isVisitable: rs }); function T(x, R) { if (!p.isUndefined(x)) { if (h.indexOf(x) !== -1) throw Error("Circular reference detected in " + R.join(".")); h.push(x), p.forEach(x, function (N, D) { (!(p.isUndefined(N) || N === null) && r.call(t, N, p.isString(D) ? D.trim() : D, R, w)) === !0 && T(N, R ? R.concat(D) : [D]) }), h.pop() } } if (!p.isObject(e)) throw new TypeError("data must be an object"); return T(e), t } function pr(e) { const t = { "!": "%21", "'": "%27", "(": "%28", ")": "%29", "~": "%7E", "%20": "+", "%00": "\0" }; return encodeURIComponent(e).replace(/[!'()~]|%20|%00/g, function (s) { return t[s] }) } function Ps(e, t) { this._pairs = [], e && Rn(e, this, t) } const Bi = Ps.prototype; Bi.append = function (t, n) { this._pairs.push([t, n]) }; Bi.toString = function (t) { const n = t ? function (s) { return t.call(this, s, pr) } : pr; return this._pairs.map(function (r) { return n(r[0]) + "=" + n(r[1]) }, "").join("&") }; function Cf(e) { return encodeURIComponent(e).replace(/%3A/gi, ":").replace(/%24/g, "$").replace(/%2C/gi, ",").replace(/%20/g, "+").replace(/%5B/gi, "[").replace(/%5D/gi, "]") } function $i(e, t, n) { if (!t) return e; const s = n && n.encode || Cf; p.isFunction(n) && (n = { serialize: n }); const r = n && n.serialize; let i; if (r ? i = r(t, n) : i = p.isURLSearchParams(t) ? t.toString() : new Ps(t, n).toString(s), i) { const o = e.indexOf("#"); o !== -1 && (e = e.slice(0, o)), e += (e.indexOf("?") === -1 ? "?" : "&") + i } return e } class mr { constructor() { this.handlers = [] } use(t, n, s) { return this.handlers.push({ fulfilled: t, rejected: n, synchronous: s ? s.synchronous : !1, runWhen: s ? s.runWhen : null }), this.handlers.length - 1 } eject(t) { this.handlers[t] && (this.handlers[t] = null) } clear() { this.handlers && (this.handlers = []) } forEach(t) { p.forEach(this.handlers, function (s) { s !== null && t(s) }) } } const qi = { silentJSONParsing: !0, forcedJSONParsing: !0, clarifyTimeoutError: !1 }, Af = typeof URLSearchParams < "u" ? URLSearchParams : Ps, Pf = typeof FormData < "u" ? FormData : null, Ff = typeof Blob < "u" ? Blob : null, Nf = { isBrowser: !0, classes: { URLSearchParams: Af, FormData: Pf, Blob: Ff }, protocols: ["http", "https", "file", "blob", "url", "data"] }, Fs = typeof window < "u" && typeof document < "u", is = typeof navigator == "object" && navigator || void 0, vf = Fs && (!is || ["ReactNative", "NativeScript", "NS"].indexOf(is.product) < 0), Lf = typeof WorkerGlobalScope < "u" && self instanceof WorkerGlobalScope && typeof self.importScripts == "function", Df = Fs && window.location.href || "http://localhost", Mf = Object.freeze(Object.defineProperty({ __proto__: null, hasBrowserEnv: Fs, hasStandardBrowserEnv: vf, hasStandardBrowserWebWorkerEnv: Lf, navigator: is, origin: Df }, Symbol.toStringTag, { value: "Module" })), ne = { ...Mf, ...Nf }; function If(e, t) { return Rn(e, new ne.classes.URLSearchParams, Object.assign({ visitor: function (n, s, r, i) { return ne.isNode && p.isBuffer(n) ? (this.append(s, n.toString("base64")), !1) : i.defaultVisitor.apply(this, arguments) } }, t)) } function Hf(e) { return p.matchAll(/\w+|\[(\w*)]/g, e).map(t => t[0] === "[]" ? "" : t[1] || t[0]) } function jf(e) { const t = {}, n = Object.keys(e); let s; const r = n.length; let i; for (s = 0; s < r; s++)i = n[s], t[i] = e[i]; return t } function Vi(e) { function t(n, s, r, i) { let o = n[i++]; if (o === "__proto__") return !0; const l = Number.isFinite(+o), c = i >= n.length; return o = !o && p.isArray(r) ? r.length : o, c ? (p.hasOwnProp(r, o) ? r[o] = [r[o], s] : r[o] = s, !l) : ((!r[o] || !p.isObject(r[o])) && (r[o] = []), t(n, s, r[o], i) && p.isArray(r[o]) && (r[o] = jf(r[o])), !l) } if (p.isFormData(e) && p.isFunction(e.entries)) { const n = {}; return p.forEachEntry(e, (s, r) => { t(Hf(s), r, n, 0) }), n } return null } function Uf(e, t, n) { if (p.isString(e)) try { return (t || JSON.parse)(e), p.trim(e) } catch (s) { if (s.name !== "SyntaxError") throw s } return (0, JSON.stringify)(e) } const Bt = { transitional: qi, adapter: ["xhr", "http", "fetch"], transformRequest: [function (t, n) { const s = n.getContentType() || "", r = s.indexOf("application/json") > -1, i = p.isObject(t); if (i && p.isHTMLForm(t) && (t = new FormData(t)), p.isFormData(t)) return r ? JSON.stringify(Vi(t)) : t; if (p.isArrayBuffer(t) || p.isBuffer(t) || p.isStream(t) || p.isFile(t) || p.isBlob(t) || p.isReadableStream(t)) return t; if (p.isArrayBufferView(t)) return t.buffer; if (p.isURLSearchParams(t)) return n.setContentType("application/x-www-form-urlencoded;charset=utf-8", !1), t.toString(); let l; if (i) { if (s.indexOf("application/x-www-form-urlencoded") > -1) return If(t, this.formSerializer).toString(); if ((l = p.isFileList(t)) || s.indexOf("multipart/form-data") > -1) { const c = this.env && this.env.FormData; return Rn(l ? { "files[]": t } : t, c && new c, this.formSerializer) } } return i || r ? (n.setContentType("application/json", !1), Uf(t)) : t }], transformResponse: [function (t) { const n = this.transitional || Bt.transitional, s = n && n.forcedJSONParsing, r = this.responseType === "json"; if (p.isResponse(t) || p.isReadableStream(t)) return t; if (t && p.isString(t) && (s && !this.responseType || r)) { const o = !(n && n.silentJSONParsing) && r; try { return JSON.parse(t) } catch (l) { if (o) throw l.name === "SyntaxError" ? M.from(l, M.ERR_BAD_RESPONSE, this, null, this.response) : l } } return t }], timeout: 0, xsrfCookieName: "XSRF-TOKEN", xsrfHeaderName: "X-XSRF-TOKEN", maxContentLength: -1, maxBodyLength: -1, env: { FormData: ne.classes.FormData, Blob: ne.classes.Blob }, validateStatus: function (t) { return t >= 200 && t < 300 }, headers: { common: { Accept: "application/json, text/plain, */*", "Content-Type": void 0 } } }; p.forEach(["delete", "get", "head", "post", "put", "patch"], e => { Bt.headers[e] = {} }); const Bf = p.toObjectSet(["age", "authorization", "content-length", "content-type", "etag", "expires", "from", "host", "if-modified-since", "if-unmodified-since", "last-modified", "location", "max-forwards", "proxy-authorization", "referer", "retry-after", "user-agent"]), $f = e => {
    const t = {}; let n, s, r; return e && e.split(`
`).forEach(function (o) { r = o.indexOf(":"), n = o.substring(0, r).trim().toLowerCase(), s = o.substring(r + 1).trim(), !(!n || t[n] && Bf[n]) && (n === "set-cookie" ? t[n] ? t[n].push(s) : t[n] = [s] : t[n] = t[n] ? t[n] + ", " + s : s) }), t
}, gr = Symbol("internals"); function xt(e) { return e && String(e).trim().toLowerCase() } function Qt(e) { return e === !1 || e == null ? e : p.isArray(e) ? e.map(Qt) : String(e) } function qf(e) { const t = Object.create(null), n = /([^\s,;=]+)\s*(?:=\s*([^,;]+))?/g; let s; for (; s = n.exec(e);)t[s[1]] = s[2]; return t } const Vf = e => /^[-_a-zA-Z0-9^`|~,!#$%&'*+.]+$/.test(e.trim()); function Vn(e, t, n, s, r) { if (p.isFunction(s)) return s.call(this, t, n); if (r && (t = n), !!p.isString(t)) { if (p.isString(s)) return t.indexOf(s) !== -1; if (p.isRegExp(s)) return s.test(t) } } function kf(e) { return e.trim().toLowerCase().replace(/([a-z\d])(\w*)/g, (t, n, s) => n.toUpperCase() + s) } function Kf(e, t) { const n = p.toCamelCase(" " + t);["get", "set", "has"].forEach(s => { Object.defineProperty(e, s + n, { value: function (r, i, o) { return this[s].call(this, t, r, i, o) }, configurable: !0 }) }) } class fe {
    constructor(t) { t && this.set(t) } set(t, n, s) { const r = this; function i(l, c, d) { const u = xt(c); if (!u) throw new Error("header name must be a non-empty string"); const h = p.findKey(r, u); (!h || r[h] === void 0 || d === !0 || d === void 0 && r[h] !== !1) && (r[h || c] = Qt(l)) } const o = (l, c) => p.forEach(l, (d, u) => i(d, u, c)); if (p.isPlainObject(t) || t instanceof this.constructor) o(t, n); else if (p.isString(t) && (t = t.trim()) && !Vf(t)) o($f(t), n); else if (p.isHeaders(t)) for (const [l, c] of t.entries()) i(c, l, s); else t != null && i(n, t, s); return this } get(t, n) { if (t = xt(t), t) { const s = p.findKey(this, t); if (s) { const r = this[s]; if (!n) return r; if (n === !0) return qf(r); if (p.isFunction(n)) return n.call(this, r, s); if (p.isRegExp(n)) return n.exec(r); throw new TypeError("parser must be boolean|regexp|function") } } } has(t, n) { if (t = xt(t), t) { const s = p.findKey(this, t); return !!(s && this[s] !== void 0 && (!n || Vn(this, this[s], s, n))) } return !1 } delete(t, n) { const s = this; let r = !1; function i(o) { if (o = xt(o), o) { const l = p.findKey(s, o); l && (!n || Vn(s, s[l], l, n)) && (delete s[l], r = !0) } } return p.isArray(t) ? t.forEach(i) : i(t), r } clear(t) { const n = Object.keys(this); let s = n.length, r = !1; for (; s--;) { const i = n[s]; (!t || Vn(this, this[i], i, t, !0)) && (delete this[i], r = !0) } return r } normalize(t) { const n = this, s = {}; return p.forEach(this, (r, i) => { const o = p.findKey(s, i); if (o) { n[o] = Qt(r), delete n[i]; return } const l = t ? kf(i) : String(i).trim(); l !== i && delete n[i], n[l] = Qt(r), s[l] = !0 }), this } concat(...t) { return this.constructor.concat(this, ...t) } toJSON(t) { const n = Object.create(null); return p.forEach(this, (s, r) => { s != null && s !== !1 && (n[r] = t && p.isArray(s) ? s.join(", ") : s) }), n } [Symbol.iterator]() { return Object.entries(this.toJSON())[Symbol.iterator]() } toString() {
        return Object.entries(this.toJSON()).map(([t, n]) => t + ": " + n).join(`
`)
    } get [Symbol.toStringTag]() { return "AxiosHeaders" } static from(t) { return t instanceof this ? t : new this(t) } static concat(t, ...n) { const s = new this(t); return n.forEach(r => s.set(r)), s } static accessor(t) { const s = (this[gr] = this[gr] = { accessors: {} }).accessors, r = this.prototype; function i(o) { const l = xt(o); s[l] || (Kf(r, o), s[l] = !0) } return p.isArray(t) ? t.forEach(i) : i(t), this }
} fe.accessor(["Content-Type", "Content-Length", "Accept", "Accept-Encoding", "User-Agent", "Authorization"]); p.reduceDescriptors(fe.prototype, ({ value: e }, t) => { let n = t[0].toUpperCase() + t.slice(1); return { get: () => e, set(s) { this[n] = s } } }); p.freezeMethods(fe); function kn(e, t) { const n = this || Bt, s = t || n, r = fe.from(s.headers); let i = s.data; return p.forEach(e, function (l) { i = l.call(n, i, r.normalize(), t ? t.status : void 0) }), r.normalize(), i } function ki(e) { return !!(e && e.__CANCEL__) } function pt(e, t, n) { M.call(this, e ?? "canceled", M.ERR_CANCELED, t, n), this.name = "CanceledError" } p.inherits(pt, M, { __CANCEL__: !0 }); function Ki(e, t, n) { const s = n.config.validateStatus; !n.status || !s || s(n.status) ? e(n) : t(new M("Request failed with status code " + n.status, [M.ERR_BAD_REQUEST, M.ERR_BAD_RESPONSE][Math.floor(n.status / 100) - 4], n.config, n.request, n)) } function Wf(e) { const t = /^([-+\w]{1,25})(:?\/\/|:)/.exec(e); return t && t[1] || "" } function zf(e, t) { e = e || 10; const n = new Array(e), s = new Array(e); let r = 0, i = 0, o; return t = t !== void 0 ? t : 1e3, function (c) { const d = Date.now(), u = s[i]; o || (o = d), n[r] = c, s[r] = d; let h = i, w = 0; for (; h !== r;)w += n[h++], h = h % e; if (r = (r + 1) % e, r === i && (i = (i + 1) % e), d - o < t) return; const T = u && d - u; return T ? Math.round(w * 1e3 / T) : void 0 } } function Jf(e, t) { let n = 0, s = 1e3 / t, r, i; const o = (d, u = Date.now()) => { n = u, r = null, i && (clearTimeout(i), i = null), e.apply(null, d) }; return [(...d) => { const u = Date.now(), h = u - n; h >= s ? o(d, u) : (r = d, i || (i = setTimeout(() => { i = null, o(r) }, s - h))) }, () => r && o(r)] } const cn = (e, t, n = 3) => { let s = 0; const r = zf(50, 250); return Jf(i => { const o = i.loaded, l = i.lengthComputable ? i.total : void 0, c = o - s, d = r(c), u = o <= l; s = o; const h = { loaded: o, total: l, progress: l ? o / l : void 0, bytes: c, rate: d || void 0, estimated: d && l && u ? (l - o) / d : void 0, event: i, lengthComputable: l != null, [t ? "download" : "upload"]: !0 }; e(h) }, n) }, br = (e, t) => { const n = e != null; return [s => t[0]({ lengthComputable: n, total: e, loaded: s }), t[1]] }, yr = e => (...t) => p.asap(() => e(...t)), Gf = ne.hasStandardBrowserEnv ? ((e, t) => n => (n = new URL(n, ne.origin), e.protocol === n.protocol && e.host === n.host && (t || e.port === n.port)))(new URL(ne.origin), ne.navigator && /(msie|trident)/i.test(ne.navigator.userAgent)) : () => !0, Xf = ne.hasStandardBrowserEnv ? { write(e, t, n, s, r, i) { const o = [e + "=" + encodeURIComponent(t)]; p.isNumber(n) && o.push("expires=" + new Date(n).toGMTString()), p.isString(s) && o.push("path=" + s), p.isString(r) && o.push("domain=" + r), i === !0 && o.push("secure"), document.cookie = o.join("; ") }, read(e) { const t = document.cookie.match(new RegExp("(^|;\\s*)(" + e + ")=([^;]*)")); return t ? decodeURIComponent(t[3]) : null }, remove(e) { this.write(e, "", Date.now() - 864e5) } } : { write() { }, read() { return null }, remove() { } }; function Yf(e) { return /^([a-z][a-z\d+\-.]*:)?\/\//i.test(e) } function Zf(e, t) { return t ? e.replace(/\/?\/$/, "") + "/" + t.replace(/^\/+/, "") : e } function Wi(e, t) { return e && !Yf(t) ? Zf(e, t) : t } const _r = e => e instanceof fe ? { ...e } : e; function st(e, t) { t = t || {}; const n = {}; function s(d, u, h, w) { return p.isPlainObject(d) && p.isPlainObject(u) ? p.merge.call({ caseless: w }, d, u) : p.isPlainObject(u) ? p.merge({}, u) : p.isArray(u) ? u.slice() : u } function r(d, u, h, w) { if (p.isUndefined(u)) { if (!p.isUndefined(d)) return s(void 0, d, h, w) } else return s(d, u, h, w) } function i(d, u) { if (!p.isUndefined(u)) return s(void 0, u) } function o(d, u) { if (p.isUndefined(u)) { if (!p.isUndefined(d)) return s(void 0, d) } else return s(void 0, u) } function l(d, u, h) { if (h in t) return s(d, u); if (h in e) return s(void 0, d) } const c = { url: i, method: i, data: i, baseURL: o, transformRequest: o, transformResponse: o, paramsSerializer: o, timeout: o, timeoutMessage: o, withCredentials: o, withXSRFToken: o, adapter: o, responseType: o, xsrfCookieName: o, xsrfHeaderName: o, onUploadProgress: o, onDownloadProgress: o, decompress: o, maxContentLength: o, maxBodyLength: o, beforeRedirect: o, transport: o, httpAgent: o, httpsAgent: o, cancelToken: o, socketPath: o, responseEncoding: o, validateStatus: l, headers: (d, u, h) => r(_r(d), _r(u), h, !0) }; return p.forEach(Object.keys(Object.assign({}, e, t)), function (u) { const h = c[u] || r, w = h(e[u], t[u], u); p.isUndefined(w) && h !== l || (n[u] = w) }), n } const zi = e => { const t = st({}, e); let { data: n, withXSRFToken: s, xsrfHeaderName: r, xsrfCookieName: i, headers: o, auth: l } = t; t.headers = o = fe.from(o), t.url = $i(Wi(t.baseURL, t.url), e.params, e.paramsSerializer), l && o.set("Authorization", "Basic " + btoa((l.username || "") + ":" + (l.password ? unescape(encodeURIComponent(l.password)) : ""))); let c; if (p.isFormData(n)) { if (ne.hasStandardBrowserEnv || ne.hasStandardBrowserWebWorkerEnv) o.setContentType(void 0); else if ((c = o.getContentType()) !== !1) { const [d, ...u] = c ? c.split(";").map(h => h.trim()).filter(Boolean) : []; o.setContentType([d || "multipart/form-data", ...u].join("; ")) } } if (ne.hasStandardBrowserEnv && (s && p.isFunction(s) && (s = s(t)), s || s !== !1 && Gf(t.url))) { const d = r && i && Xf.read(i); d && o.set(r, d) } return t }, Qf = typeof XMLHttpRequest < "u", eu = Qf && function (e) { return new Promise(function (n, s) { const r = zi(e); let i = r.data; const o = fe.from(r.headers).normalize(); let { responseType: l, onUploadProgress: c, onDownloadProgress: d } = r, u, h, w, T, x; function R() { T && T(), x && x(), r.cancelToken && r.cancelToken.unsubscribe(u), r.signal && r.signal.removeEventListener("abort", u) } let C = new XMLHttpRequest; C.open(r.method.toUpperCase(), r.url, !0), C.timeout = r.timeout; function N() { if (!C) return; const H = fe.from("getAllResponseHeaders" in C && C.getAllResponseHeaders()), U = { data: !l || l === "text" || l === "json" ? C.responseText : C.response, status: C.status, statusText: C.statusText, headers: H, config: e, request: C }; Ki(function (Z) { n(Z), R() }, function (Z) { s(Z), R() }, U), C = null } "onloadend" in C ? C.onloadend = N : C.onreadystatechange = function () { !C || C.readyState !== 4 || C.status === 0 && !(C.responseURL && C.responseURL.indexOf("file:") === 0) || setTimeout(N) }, C.onabort = function () { C && (s(new M("Request aborted", M.ECONNABORTED, e, C)), C = null) }, C.onerror = function () { s(new M("Network Error", M.ERR_NETWORK, e, C)), C = null }, C.ontimeout = function () { let P = r.timeout ? "timeout of " + r.timeout + "ms exceeded" : "timeout exceeded"; const U = r.transitional || qi; r.timeoutErrorMessage && (P = r.timeoutErrorMessage), s(new M(P, U.clarifyTimeoutError ? M.ETIMEDOUT : M.ECONNABORTED, e, C)), C = null }, i === void 0 && o.setContentType(null), "setRequestHeader" in C && p.forEach(o.toJSON(), function (P, U) { C.setRequestHeader(U, P) }), p.isUndefined(r.withCredentials) || (C.withCredentials = !!r.withCredentials), l && l !== "json" && (C.responseType = r.responseType), d && ([w, x] = cn(d, !0), C.addEventListener("progress", w)), c && C.upload && ([h, T] = cn(c), C.upload.addEventListener("progress", h), C.upload.addEventListener("loadend", T)), (r.cancelToken || r.signal) && (u = H => { C && (s(!H || H.type ? new pt(null, e, C) : H), C.abort(), C = null) }, r.cancelToken && r.cancelToken.subscribe(u), r.signal && (r.signal.aborted ? u() : r.signal.addEventListener("abort", u))); const D = Wf(r.url); if (D && ne.protocols.indexOf(D) === -1) { s(new M("Unsupported protocol " + D + ":", M.ERR_BAD_REQUEST, e)); return } C.send(i || null) }) }, tu = (e, t) => { const { length: n } = e = e ? e.filter(Boolean) : []; if (t || n) { let s = new AbortController, r; const i = function (d) { if (!r) { r = !0, l(); const u = d instanceof Error ? d : this.reason; s.abort(u instanceof M ? u : new pt(u instanceof Error ? u.message : u)) } }; let o = t && setTimeout(() => { o = null, i(new M(`timeout ${t} of ms exceeded`, M.ETIMEDOUT)) }, t); const l = () => { e && (o && clearTimeout(o), o = null, e.forEach(d => { d.unsubscribe ? d.unsubscribe(i) : d.removeEventListener("abort", i) }), e = null) }; e.forEach(d => d.addEventListener("abort", i)); const { signal: c } = s; return c.unsubscribe = () => p.asap(l), c } }, nu = function* (e, t) { let n = e.byteLength; if (n < t) { yield e; return } let s = 0, r; for (; s < n;)r = s + t, yield e.slice(s, r), s = r }, su = async function* (e, t) { for await (const n of ru(e)) yield* nu(n, t) }, ru = async function* (e) { if (e[Symbol.asyncIterator]) { yield* e; return } const t = e.getReader(); try { for (; ;) { const { done: n, value: s } = await t.read(); if (n) break; yield s } } finally { await t.cancel() } }, wr = (e, t, n, s) => { const r = su(e, t); let i = 0, o, l = c => { o || (o = !0, s && s(c)) }; return new ReadableStream({ async pull(c) { try { const { done: d, value: u } = await r.next(); if (d) { l(), c.close(); return } let h = u.byteLength; if (n) { let w = i += h; n(w) } c.enqueue(new Uint8Array(u)) } catch (d) { throw l(d), d } }, cancel(c) { return l(c), r.return() } }, { highWaterMark: 2 }) }, On = typeof fetch == "function" && typeof Request == "function" && typeof Response == "function", Ji = On && typeof ReadableStream == "function", iu = On && (typeof TextEncoder == "function" ? (e => t => e.encode(t))(new TextEncoder) : async e => new Uint8Array(await new Response(e).arrayBuffer())), Gi = (e, ...t) => { try { return !!e(...t) } catch { return !1 } }, ou = Ji && Gi(() => { let e = !1; const t = new Request(ne.origin, { body: new ReadableStream, method: "POST", get duplex() { return e = !0, "half" } }).headers.has("Content-Type"); return e && !t }), xr = 64 * 1024, os = Ji && Gi(() => p.isReadableStream(new Response("").body)), fn = { stream: os && (e => e.body) }; On && (e => { ["text", "arrayBuffer", "blob", "formData", "stream"].forEach(t => { !fn[t] && (fn[t] = p.isFunction(e[t]) ? n => n[t]() : (n, s) => { throw new M(`Response type '${t}' is not supported`, M.ERR_NOT_SUPPORT, s) }) }) })(new Response); const lu = async e => { if (e == null) return 0; if (p.isBlob(e)) return e.size; if (p.isSpecCompliantForm(e)) return (await new Request(ne.origin, { method: "POST", body: e }).arrayBuffer()).byteLength; if (p.isArrayBufferView(e) || p.isArrayBuffer(e)) return e.byteLength; if (p.isURLSearchParams(e) && (e = e + ""), p.isString(e)) return (await iu(e)).byteLength }, cu = async (e, t) => { const n = p.toFiniteNumber(e.getContentLength()); return n ?? lu(t) }, fu = On && (async e => { let { url: t, method: n, data: s, signal: r, cancelToken: i, timeout: o, onDownloadProgress: l, onUploadProgress: c, responseType: d, headers: u, withCredentials: h = "same-origin", fetchOptions: w } = zi(e); d = d ? (d + "").toLowerCase() : "text"; let T = tu([r, i && i.toAbortSignal()], o), x; const R = T && T.unsubscribe && (() => { T.unsubscribe() }); let C; try { if (c && ou && n !== "get" && n !== "head" && (C = await cu(u, s)) !== 0) { let U = new Request(t, { method: "POST", body: s, duplex: "half" }), Q; if (p.isFormData(s) && (Q = U.headers.get("content-type")) && u.setContentType(Q), U.body) { const [Z, ue] = br(C, cn(yr(c))); s = wr(U.body, xr, Z, ue) } } p.isString(h) || (h = h ? "include" : "omit"); const N = "credentials" in Request.prototype; x = new Request(t, { ...w, signal: T, method: n.toUpperCase(), headers: u.normalize().toJSON(), body: s, duplex: "half", credentials: N ? h : void 0 }); let D = await fetch(x); const H = os && (d === "stream" || d === "response"); if (os && (l || H && R)) { const U = {};["status", "statusText", "headers"].forEach(We => { U[We] = D[We] }); const Q = p.toFiniteNumber(D.headers.get("content-length")), [Z, ue] = l && br(Q, cn(yr(l), !0)) || []; D = new Response(wr(D.body, xr, Z, () => { ue && ue(), R && R() }), U) } d = d || "text"; let P = await fn[p.findKey(fn, d) || "text"](D, e); return !H && R && R(), await new Promise((U, Q) => { Ki(U, Q, { data: P, headers: fe.from(D.headers), status: D.status, statusText: D.statusText, config: e, request: x }) }) } catch (N) { throw R && R(), N && N.name === "TypeError" && /fetch/i.test(N.message) ? Object.assign(new M("Network Error", M.ERR_NETWORK, e, x), { cause: N.cause || N }) : M.from(N, N && N.code, e, x) } }), ls = { http: Tf, xhr: eu, fetch: fu }; p.forEach(ls, (e, t) => { if (e) { try { Object.defineProperty(e, "name", { value: t }) } catch { } Object.defineProperty(e, "adapterName", { value: t }) } }); const Sr = e => `- ${e}`, uu = e => p.isFunction(e) || e === null || e === !1, Xi = {
    getAdapter: e => {
        e = p.isArray(e) ? e : [e]; const { length: t } = e; let n, s; const r = {}; for (let i = 0; i < t; i++) { n = e[i]; let o; if (s = n, !uu(n) && (s = ls[(o = String(n)).toLowerCase()], s === void 0)) throw new M(`Unknown adapter '${o}'`); if (s) break; r[o || "#" + i] = s } if (!s) {
            const i = Object.entries(r).map(([l, c]) => `adapter ${l} ` + (c === !1 ? "is not supported by the environment" : "is not available in the build")); let o = t ? i.length > 1 ? `since :
`+ i.map(Sr).join(`
`) : " " + Sr(i[0]) : "as no adapter specified"; throw new M("There is no suitable adapter to dispatch the request " + o, "ERR_NOT_SUPPORT")
        } return s
    }, adapters: ls
}; function Kn(e) { if (e.cancelToken && e.cancelToken.throwIfRequested(), e.signal && e.signal.aborted) throw new pt(null, e) } function Er(e) { return Kn(e), e.headers = fe.from(e.headers), e.data = kn.call(e, e.transformRequest), ["post", "put", "patch"].indexOf(e.method) !== -1 && e.headers.setContentType("application/x-www-form-urlencoded", !1), Xi.getAdapter(e.adapter || Bt.adapter)(e).then(function (s) { return Kn(e), s.data = kn.call(e, e.transformResponse, s), s.headers = fe.from(s.headers), s }, function (s) { return ki(s) || (Kn(e), s && s.response && (s.response.data = kn.call(e, e.transformResponse, s.response), s.response.headers = fe.from(s.response.headers))), Promise.reject(s) }) } const Yi = "1.7.9", Cn = {};["object", "boolean", "number", "function", "string", "symbol"].forEach((e, t) => { Cn[e] = function (s) { return typeof s === e || "a" + (t < 1 ? "n " : " ") + e } }); const Tr = {}; Cn.transitional = function (t, n, s) { function r(i, o) { return "[Axios v" + Yi + "] Transitional option '" + i + "'" + o + (s ? ". " + s : "") } return (i, o, l) => { if (t === !1) throw new M(r(o, " has been removed" + (n ? " in " + n : "")), M.ERR_DEPRECATED); return n && !Tr[o] && (Tr[o] = !0, console.warn(r(o, " has been deprecated since v" + n + " and will be removed in the near future"))), t ? t(i, o, l) : !0 } }; Cn.spelling = function (t) { return (n, s) => (console.warn(`${s} is likely a misspelling of ${t}`), !0) }; function au(e, t, n) { if (typeof e != "object") throw new M("options must be an object", M.ERR_BAD_OPTION_VALUE); const s = Object.keys(e); let r = s.length; for (; r-- > 0;) { const i = s[r], o = t[i]; if (o) { const l = e[i], c = l === void 0 || o(l, i, e); if (c !== !0) throw new M("option " + i + " must be " + c, M.ERR_BAD_OPTION_VALUE); continue } if (n !== !0) throw new M("Unknown option " + i, M.ERR_BAD_OPTION) } } const en = { assertOptions: au, validators: Cn }, Ae = en.validators; class nt {
    constructor(t) { this.defaults = t, this.interceptors = { request: new mr, response: new mr } } async request(t, n) {
        try { return await this._request(t, n) } catch (s) {
            if (s instanceof Error) {
                let r = {}; Error.captureStackTrace ? Error.captureStackTrace(r) : r = new Error; const i = r.stack ? r.stack.replace(/^.+\n/, "") : ""; try {
                    s.stack ? i && !String(s.stack).endsWith(i.replace(/^.+\n.+\n/, "")) && (s.stack += `
`+ i) : s.stack = i
                } catch { }
            } throw s
        }
    } _request(t, n) { typeof t == "string" ? (n = n || {}, n.url = t) : n = t || {}, n = st(this.defaults, n); const { transitional: s, paramsSerializer: r, headers: i } = n; s !== void 0 && en.assertOptions(s, { silentJSONParsing: Ae.transitional(Ae.boolean), forcedJSONParsing: Ae.transitional(Ae.boolean), clarifyTimeoutError: Ae.transitional(Ae.boolean) }, !1), r != null && (p.isFunction(r) ? n.paramsSerializer = { serialize: r } : en.assertOptions(r, { encode: Ae.function, serialize: Ae.function }, !0)), en.assertOptions(n, { baseUrl: Ae.spelling("baseURL"), withXsrfToken: Ae.spelling("withXSRFToken") }, !0), n.method = (n.method || this.defaults.method || "get").toLowerCase(); let o = i && p.merge(i.common, i[n.method]); i && p.forEach(["delete", "get", "head", "post", "put", "patch", "common"], x => { delete i[x] }), n.headers = fe.concat(o, i); const l = []; let c = !0; this.interceptors.request.forEach(function (R) { typeof R.runWhen == "function" && R.runWhen(n) === !1 || (c = c && R.synchronous, l.unshift(R.fulfilled, R.rejected)) }); const d = []; this.interceptors.response.forEach(function (R) { d.push(R.fulfilled, R.rejected) }); let u, h = 0, w; if (!c) { const x = [Er.bind(this), void 0]; for (x.unshift.apply(x, l), x.push.apply(x, d), w = x.length, u = Promise.resolve(n); h < w;)u = u.then(x[h++], x[h++]); return u } w = l.length; let T = n; for (h = 0; h < w;) { const x = l[h++], R = l[h++]; try { T = x(T) } catch (C) { R.call(this, C); break } } try { u = Er.call(this, T) } catch (x) { return Promise.reject(x) } for (h = 0, w = d.length; h < w;)u = u.then(d[h++], d[h++]); return u } getUri(t) { t = st(this.defaults, t); const n = Wi(t.baseURL, t.url); return $i(n, t.params, t.paramsSerializer) }
} p.forEach(["delete", "get", "head", "options"], function (t) { nt.prototype[t] = function (n, s) { return this.request(st(s || {}, { method: t, url: n, data: (s || {}).data })) } }); p.forEach(["post", "put", "patch"], function (t) { function n(s) { return function (i, o, l) { return this.request(st(l || {}, { method: t, headers: s ? { "Content-Type": "multipart/form-data" } : {}, url: i, data: o })) } } nt.prototype[t] = n(), nt.prototype[t + "Form"] = n(!0) }); class Ns { constructor(t) { if (typeof t != "function") throw new TypeError("executor must be a function."); let n; this.promise = new Promise(function (i) { n = i }); const s = this; this.promise.then(r => { if (!s._listeners) return; let i = s._listeners.length; for (; i-- > 0;)s._listeners[i](r); s._listeners = null }), this.promise.then = r => { let i; const o = new Promise(l => { s.subscribe(l), i = l }).then(r); return o.cancel = function () { s.unsubscribe(i) }, o }, t(function (i, o, l) { s.reason || (s.reason = new pt(i, o, l), n(s.reason)) }) } throwIfRequested() { if (this.reason) throw this.reason } subscribe(t) { if (this.reason) { t(this.reason); return } this._listeners ? this._listeners.push(t) : this._listeners = [t] } unsubscribe(t) { if (!this._listeners) return; const n = this._listeners.indexOf(t); n !== -1 && this._listeners.splice(n, 1) } toAbortSignal() { const t = new AbortController, n = s => { t.abort(s) }; return this.subscribe(n), t.signal.unsubscribe = () => this.unsubscribe(n), t.signal } static source() { let t; return { token: new Ns(function (r) { t = r }), cancel: t } } } function du(e) { return function (n) { return e.apply(null, n) } } function hu(e) { return p.isObject(e) && e.isAxiosError === !0 } const cs = { Continue: 100, SwitchingProtocols: 101, Processing: 102, EarlyHints: 103, Ok: 200, Created: 201, Accepted: 202, NonAuthoritativeInformation: 203, NoContent: 204, ResetContent: 205, PartialContent: 206, MultiStatus: 207, AlreadyReported: 208, ImUsed: 226, MultipleChoices: 300, MovedPermanently: 301, Found: 302, SeeOther: 303, NotModified: 304, UseProxy: 305, Unused: 306, TemporaryRedirect: 307, PermanentRedirect: 308, BadRequest: 400, Unauthorized: 401, PaymentRequired: 402, Forbidden: 403, NotFound: 404, MethodNotAllowed: 405, NotAcceptable: 406, ProxyAuthenticationRequired: 407, RequestTimeout: 408, Conflict: 409, Gone: 410, LengthRequired: 411, PreconditionFailed: 412, PayloadTooLarge: 413, UriTooLong: 414, UnsupportedMediaType: 415, RangeNotSatisfiable: 416, ExpectationFailed: 417, ImATeapot: 418, MisdirectedRequest: 421, UnprocessableEntity: 422, Locked: 423, FailedDependency: 424, TooEarly: 425, UpgradeRequired: 426, PreconditionRequired: 428, TooManyRequests: 429, RequestHeaderFieldsTooLarge: 431, UnavailableForLegalReasons: 451, InternalServerError: 500, NotImplemented: 501, BadGateway: 502, ServiceUnavailable: 503, GatewayTimeout: 504, HttpVersionNotSupported: 505, VariantAlsoNegotiates: 506, InsufficientStorage: 507, LoopDetected: 508, NotExtended: 510, NetworkAuthenticationRequired: 511 }; Object.entries(cs).forEach(([e, t]) => { cs[t] = e }); function Zi(e) { const t = new nt(e), n = Pi(nt.prototype.request, t); return p.extend(n, nt.prototype, t, { allOwnKeys: !0 }), p.extend(n, t, null, { allOwnKeys: !0 }), n.create = function (r) { return Zi(st(e, r)) }, n } const X = Zi(Bt); X.Axios = nt; X.CanceledError = pt; X.CancelToken = Ns; X.isCancel = ki; X.VERSION = Yi; X.toFormData = Rn; X.AxiosError = M; X.Cancel = X.CanceledError; X.all = function (t) { return Promise.all(t) }; X.spread = du; X.isAxiosError = hu; X.mergeConfig = st; X.AxiosHeaders = fe; X.formToJSON = e => Vi(p.isHTMLForm(e) ? new FormData(e) : e); X.getAdapter = Xi.getAdapter; X.HttpStatusCode = cs; X.default = X; const pu = { data() { return { title: "" } }, methods: { chickenHandel() { console.log("我被点击了"), this.replaceTextHandle() }, replaceTextHandle() { X.get("https://www.kouleen.cn/v1/phone/soul/random").then(e => { this.$emit("someEvent", e.data.data.title) }).catch(e => { console.error(e) }) } }, mounted() { console.log("ChickenLine 加载完毕"), this.replaceTextHandle() } }, mu = { class: "foot-1", style: { position: "absolute", bottom: "7vh", width: "100%" } }, gu = { class: "container" }, bu = { class: "row" }, yu = { class: "col text-center" }, _u = { class: "btn btn-primary btn-filled btn-xs" }; function wu(e, t, n, s, r, i) { return _n(), wn("div", mu, [Ne("div", gu, [Ne("div", bu, [Ne("div", yu, [t[1] || (t[1] = Ne("p", { class: "lead text" }, "截屏分享朋友", -1)), Ne("span", _u, [Ne("a", { class: "btn btn-primary btn-filled btn-xs", onClick: t[0] || (t[0] = (...o) => i.chickenHandel && i.chickenHandel(...o)), href: "#" }, "www.nows.fun")])])])])]) } const xu = xn(pu, [["render", wu]]), Su = { data() { return { data: "" } }, components: { ChickenHeader: Nc, ChickenMain: Hc, ChickenLine: xu }, methods: { getHandle(e) { this.data = e } } }; function Eu(e, t, n, s, r, i) { const o = In("ChickenHeader"), l = In("ChickenMain"), c = In("ChickenLine"); return _n(), wn(Fe, null, [xe(o), xe(l, { messsage: r.data }, null, 8, ["messsage"]), xe(c, { onSomeEvent: i.getHandle }, null, 8, ["onSomeEvent"])], 64) } const Tu = xn(Su, [["render", Eu]]); Rc(Tu).mount("#app");
